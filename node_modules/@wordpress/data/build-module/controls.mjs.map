{
  "version": 3,
  "sources": ["../src/controls.js"],
  "sourcesContent": ["/**\n * Internal dependencies\n */\nimport { createRegistryControl } from './factory';\n\n/** @typedef {import('./types').StoreDescriptor} StoreDescriptor */\n\nconst SELECT = '@@data/SELECT';\nconst RESOLVE_SELECT = '@@data/RESOLVE_SELECT';\nconst DISPATCH = '@@data/DISPATCH';\n\nfunction isObject( object ) {\n\treturn object !== null && typeof object === 'object';\n}\n\n/**\n * Dispatches a control action for triggering a synchronous registry select.\n *\n * Note: This control synchronously returns the current selector value, triggering the\n * resolution, but not waiting for it.\n *\n * @param {string|StoreDescriptor} storeNameOrDescriptor Unique namespace identifier for the store\n * @param {string}                 selectorName          The name of the selector.\n * @param {Array}                  args                  Arguments for the selector.\n *\n * @example\n * ```js\n * import { controls } from '@wordpress/data';\n *\n * // Action generator using `select`.\n * export function* myAction() {\n *   const isEditorSideBarOpened = yield controls.select( 'core/edit-post', 'isEditorSideBarOpened' );\n *   // Do stuff with the result from the `select`.\n * }\n * ```\n *\n * @return {Object} The control descriptor.\n */\nfunction select( storeNameOrDescriptor, selectorName, ...args ) {\n\treturn {\n\t\ttype: SELECT,\n\t\tstoreKey: isObject( storeNameOrDescriptor )\n\t\t\t? storeNameOrDescriptor.name\n\t\t\t: storeNameOrDescriptor,\n\t\tselectorName,\n\t\targs,\n\t};\n}\n\n/**\n * Dispatches a control action for triggering and resolving a registry select.\n *\n * Note: when this control action is handled, it automatically considers\n * selectors that may have a resolver. In such case, it will return a `Promise` that resolves\n * after the selector finishes resolving, with the final result value.\n *\n * @param {string|StoreDescriptor} storeNameOrDescriptor Unique namespace identifier for the store\n * @param {string}                 selectorName          The name of the selector\n * @param {Array}                  args                  Arguments for the selector.\n *\n * @example\n * ```js\n * import { controls } from '@wordpress/data';\n *\n * // Action generator using resolveSelect\n * export function* myAction() {\n * \tconst isSidebarOpened = yield controls.resolveSelect( 'core/edit-post', 'isEditorSideBarOpened' );\n * \t// do stuff with the result from the select.\n * }\n * ```\n *\n * @return {Object} The control descriptor.\n */\nfunction resolveSelect( storeNameOrDescriptor, selectorName, ...args ) {\n\treturn {\n\t\ttype: RESOLVE_SELECT,\n\t\tstoreKey: isObject( storeNameOrDescriptor )\n\t\t\t? storeNameOrDescriptor.name\n\t\t\t: storeNameOrDescriptor,\n\t\tselectorName,\n\t\targs,\n\t};\n}\n\n/**\n * Dispatches a control action for triggering a registry dispatch.\n *\n * @param {string|StoreDescriptor} storeNameOrDescriptor Unique namespace identifier for the store\n * @param {string}                 actionName            The name of the action to dispatch\n * @param {Array}                  args                  Arguments for the dispatch action.\n *\n * @example\n * ```js\n * import { controls } from '@wordpress/data-controls';\n *\n * // Action generator using dispatch\n * export function* myAction() {\n *   yield controls.dispatch( 'core/editor', 'togglePublishSidebar' );\n *   // do some other things.\n * }\n * ```\n *\n * @return {Object}  The control descriptor.\n */\nfunction dispatch( storeNameOrDescriptor, actionName, ...args ) {\n\treturn {\n\t\ttype: DISPATCH,\n\t\tstoreKey: isObject( storeNameOrDescriptor )\n\t\t\t? storeNameOrDescriptor.name\n\t\t\t: storeNameOrDescriptor,\n\t\tactionName,\n\t\targs,\n\t};\n}\n\nexport const controls = { select, resolveSelect, dispatch };\n\nexport const builtinControls = {\n\t[ SELECT ]: createRegistryControl(\n\t\t( registry ) =>\n\t\t\t( { storeKey, selectorName, args } ) =>\n\t\t\t\tregistry.select( storeKey )[ selectorName ]( ...args )\n\t),\n\t[ RESOLVE_SELECT ]: createRegistryControl(\n\t\t( registry ) =>\n\t\t\t( { storeKey, selectorName, args } ) => {\n\t\t\t\tconst method = registry.select( storeKey )[ selectorName ]\n\t\t\t\t\t.hasResolver\n\t\t\t\t\t? 'resolveSelect'\n\t\t\t\t\t: 'select';\n\t\t\t\treturn registry[ method ]( storeKey )[ selectorName ](\n\t\t\t\t\t...args\n\t\t\t\t);\n\t\t\t}\n\t),\n\t[ DISPATCH ]: createRegistryControl(\n\t\t( registry ) =>\n\t\t\t( { storeKey, actionName, args } ) =>\n\t\t\t\tregistry.dispatch( storeKey )[ actionName ]( ...args )\n\t),\n};\n"],
  "mappings": ";AAGA,SAAS,6BAA6B;AAItC,IAAM,SAAS;AACf,IAAM,iBAAiB;AACvB,IAAM,WAAW;AAEjB,SAAS,SAAU,QAAS;AAC3B,SAAO,WAAW,QAAQ,OAAO,WAAW;AAC7C;AAyBA,SAAS,OAAQ,uBAAuB,iBAAiB,MAAO;AAC/D,SAAO;AAAA,IACN,MAAM;AAAA,IACN,UAAU,SAAU,qBAAsB,IACvC,sBAAsB,OACtB;AAAA,IACH;AAAA,IACA;AAAA,EACD;AACD;AA0BA,SAAS,cAAe,uBAAuB,iBAAiB,MAAO;AACtE,SAAO;AAAA,IACN,MAAM;AAAA,IACN,UAAU,SAAU,qBAAsB,IACvC,sBAAsB,OACtB;AAAA,IACH;AAAA,IACA;AAAA,EACD;AACD;AAsBA,SAAS,SAAU,uBAAuB,eAAe,MAAO;AAC/D,SAAO;AAAA,IACN,MAAM;AAAA,IACN,UAAU,SAAU,qBAAsB,IACvC,sBAAsB,OACtB;AAAA,IACH;AAAA,IACA;AAAA,EACD;AACD;AAEO,IAAM,WAAW,EAAE,QAAQ,eAAe,SAAS;AAEnD,IAAM,kBAAkB;AAAA,EAC9B,CAAE,MAAO,GAAG;AAAA,IACX,CAAE,aACD,CAAE,EAAE,UAAU,cAAc,KAAK,MAChC,SAAS,OAAQ,QAAS,EAAG,YAAa,EAAG,GAAG,IAAK;AAAA,EACxD;AAAA,EACA,CAAE,cAAe,GAAG;AAAA,IACnB,CAAE,aACD,CAAE,EAAE,UAAU,cAAc,KAAK,MAAO;AACvC,YAAM,SAAS,SAAS,OAAQ,QAAS,EAAG,YAAa,EACvD,cACC,kBACA;AACH,aAAO,SAAU,MAAO,EAAG,QAAS,EAAG,YAAa;AAAA,QACnD,GAAG;AAAA,MACJ;AAAA,IACD;AAAA,EACF;AAAA,EACA,CAAE,QAAS,GAAG;AAAA,IACb,CAAE,aACD,CAAE,EAAE,UAAU,YAAY,KAAK,MAC9B,SAAS,SAAU,QAAS,EAAG,UAAW,EAAG,GAAG,IAAK;AAAA,EACxD;AACD;",
  "names": []
}
