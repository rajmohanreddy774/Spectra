{
  "version": 3,
  "sources": ["../../src/component/use-anchor.js"],
  "sourcesContent": ["/**\n * WordPress dependencies\n */\nimport { usePrevious } from '@wordpress/compose';\nimport { useState, useLayoutEffect } from '@wordpress/element';\nimport { getRectangleFromRange } from '@wordpress/dom';\n\n/** @typedef {import('../register-format-type').WPFormat} WPFormat */\n/** @typedef {import('../types').RichTextValue} RichTextValue */\n\n/**\n * Given a range and a format tag name and class name, returns the closest\n * format element.\n *\n * @param {Range}       range                  The Range to check.\n * @param {HTMLElement} editableContentElement The editable wrapper.\n * @param {string}      tagName                The tag name of the format element.\n * @param {string}      className              The class name of the format element.\n *\n * @return {HTMLElement|undefined} The format element, if found.\n */\nfunction getFormatElement( range, editableContentElement, tagName, className ) {\n\tlet element = range.startContainer;\n\n\t// Even if the active format is defined, the actually DOM range's start\n\t// container may be outside of the format's DOM element:\n\t// `a\u2038<strong>b</strong>` (DOM) while visually it's `a<strong>\u2038b</strong>`.\n\t// So at a given selection index, start with the deepest format DOM element.\n\tif (\n\t\telement.nodeType === element.TEXT_NODE &&\n\t\trange.startOffset === element.length &&\n\t\telement.nextSibling\n\t) {\n\t\telement = element.nextSibling;\n\n\t\twhile ( element.firstChild ) {\n\t\t\telement = element.firstChild;\n\t\t}\n\t}\n\n\tif ( element.nodeType !== element.ELEMENT_NODE ) {\n\t\telement = element.parentElement;\n\t}\n\n\tif ( ! element ) {\n\t\treturn;\n\t}\n\tif ( element === editableContentElement ) {\n\t\treturn;\n\t}\n\tif ( ! editableContentElement.contains( element ) ) {\n\t\treturn;\n\t}\n\n\tconst selector = tagName + ( className ? '.' + className : '' );\n\n\t// .closest( selector ), but with a boundary. Check if the element matches\n\t// the selector. If it doesn't match, try the parent element if it's not the\n\t// editable wrapper. We don't want to try to match ancestors of the editable\n\t// wrapper, which is what .closest( selector ) would do. When the element is\n\t// the editable wrapper (which is most likely the case because most text is\n\t// unformatted), this never runs.\n\twhile ( element !== editableContentElement ) {\n\t\tif ( element.matches( selector ) ) {\n\t\t\treturn element;\n\t\t}\n\n\t\telement = element.parentElement;\n\t}\n}\n\n/**\n * @typedef {Object} VirtualAnchorElement\n * @property {() => DOMRect} getBoundingClientRect A function returning a DOMRect\n * @property {HTMLElement}   contextElement        The actual DOM element\n */\n\n/**\n * Creates a virtual anchor element for a range.\n *\n * @param {Range}       range                  The range to create a virtual anchor element for.\n * @param {HTMLElement} editableContentElement The editable wrapper.\n *\n * @return {VirtualAnchorElement} The virtual anchor element.\n */\nfunction createVirtualAnchorElement( range, editableContentElement ) {\n\treturn {\n\t\tcontextElement: editableContentElement,\n\t\tgetBoundingClientRect() {\n\t\t\treturn editableContentElement.contains( range.startContainer )\n\t\t\t\t? getRectangleFromRange( range )\n\t\t\t\t: editableContentElement.getBoundingClientRect();\n\t\t},\n\t};\n}\n\n/**\n * Get the anchor: a format element if there is a matching one based on the\n * tagName and className or a range otherwise.\n *\n * @param {HTMLElement} editableContentElement The editable wrapper.\n * @param {string}      tagName                The tag name of the format\n *                                             element.\n * @param {string}      className              The class name of the format\n *                                             element.\n *\n * @return {HTMLElement|VirtualAnchorElement|undefined} The anchor.\n */\nfunction getAnchor( editableContentElement, tagName, className ) {\n\tif ( ! editableContentElement ) {\n\t\treturn;\n\t}\n\n\tconst { ownerDocument } = editableContentElement;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView.getSelection();\n\n\tif ( ! selection ) {\n\t\treturn;\n\t}\n\tif ( ! selection.rangeCount ) {\n\t\treturn;\n\t}\n\n\tconst range = selection.getRangeAt( 0 );\n\n\tif ( ! range || ! range.startContainer ) {\n\t\treturn;\n\t}\n\n\tconst formatElement = getFormatElement(\n\t\trange,\n\t\teditableContentElement,\n\t\ttagName,\n\t\tclassName\n\t);\n\n\tif ( formatElement ) {\n\t\treturn formatElement;\n\t}\n\n\treturn createVirtualAnchorElement( range, editableContentElement );\n}\n\n/**\n * This hook, to be used in a format type's Edit component, returns the active\n * element that is formatted, or a virtual element for the selection range if\n * no format is active. The returned value is meant to be used for positioning\n * UI, e.g. by passing it to the `Popover` component via the `anchor` prop.\n *\n * @param {Object}           $1                        Named parameters.\n * @param {HTMLElement|null} $1.editableContentElement The element containing\n *                                                     the editable content.\n * @param {WPFormat=}        $1.settings               The format type's settings.\n * @return {Element|VirtualAnchorElement|undefined|null} The active element or selection range.\n */\nexport function useAnchor( { editableContentElement, settings = {} } ) {\n\tconst { tagName, className, isActive } = settings;\n\tconst [ anchor, setAnchor ] = useState( () =>\n\t\tgetAnchor( editableContentElement, tagName, className )\n\t);\n\tconst wasActive = usePrevious( isActive );\n\n\tuseLayoutEffect( () => {\n\t\tif ( ! editableContentElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction callback() {\n\t\t\tsetAnchor(\n\t\t\t\tgetAnchor( editableContentElement, tagName, className )\n\t\t\t);\n\t\t}\n\n\t\tfunction attach() {\n\t\t\townerDocument.addEventListener( 'selectionchange', callback );\n\t\t}\n\n\t\tfunction detach() {\n\t\t\townerDocument.removeEventListener( 'selectionchange', callback );\n\t\t}\n\n\t\tconst { ownerDocument } = editableContentElement;\n\n\t\tif (\n\t\t\teditableContentElement === ownerDocument.activeElement ||\n\t\t\t// When a link is created, we need to attach the popover to the newly created anchor.\n\t\t\t( ! wasActive && isActive ) ||\n\t\t\t// Sometimes we're _removing_ an active anchor, such as the inline color popover.\n\t\t\t// When we add the color, it switches from a virtual anchor to a `<mark>` element.\n\t\t\t// When we _remove_ the color, it switches from a `<mark>` element to a virtual anchor.\n\t\t\t( wasActive && ! isActive )\n\t\t) {\n\t\t\tsetAnchor(\n\t\t\t\tgetAnchor( editableContentElement, tagName, className )\n\t\t\t);\n\t\t\tattach();\n\t\t}\n\n\t\teditableContentElement.addEventListener( 'focusin', attach );\n\t\teditableContentElement.addEventListener( 'focusout', detach );\n\n\t\treturn () => {\n\t\t\tdetach();\n\n\t\t\teditableContentElement.removeEventListener( 'focusin', attach );\n\t\t\teditableContentElement.removeEventListener( 'focusout', detach );\n\t\t};\n\t}, [ editableContentElement, tagName, className, isActive, wasActive ] );\n\n\treturn anchor;\n}\n"],
  "mappings": "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",
  "names": []
}
