{
  "version": 3,
  "sources": ["../src/apply-format.js"],
  "sourcesContent": ["/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\nfunction replace( array, index, value ) {\n\tarray = array.slice();\n\tarray[ index ] = value;\n\treturn array;\n}\n\n/**\n * Apply a format object to a Rich Text value from the given `startIndex` to the\n * given `endIndex`. Indices are retrieved from the selection if none are\n * provided.\n *\n * @param {RichTextValue}  value        Value to modify.\n * @param {RichTextFormat} format       Format to apply.\n * @param {number}         [startIndex] Start index.\n * @param {number}         [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the format applied.\n */\nexport function applyFormat(\n\tvalue,\n\tformat,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, activeFormats } = value;\n\tconst newFormats = formats.slice();\n\n\t// The selection is collapsed.\n\tif ( startIndex === endIndex ) {\n\t\tconst startFormat = newFormats[ startIndex ]?.find(\n\t\t\t( { type } ) => type === format.type\n\t\t);\n\n\t\t// If the caret is at a format of the same type, expand start and end to\n\t\t// the edges of the format. This is useful to apply new attributes.\n\t\tif ( startFormat ) {\n\t\t\tconst index = newFormats[ startIndex ].indexOf( startFormat );\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ startIndex ] &&\n\t\t\t\tnewFormats[ startIndex ][ index ] === startFormat\n\t\t\t) {\n\t\t\t\tnewFormats[ startIndex ] = replace(\n\t\t\t\t\tnewFormats[ startIndex ],\n\t\t\t\t\tindex,\n\t\t\t\t\tformat\n\t\t\t\t);\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ endIndex ] &&\n\t\t\t\tnewFormats[ endIndex ][ index ] === startFormat\n\t\t\t) {\n\t\t\t\tnewFormats[ endIndex ] = replace(\n\t\t\t\t\tnewFormats[ endIndex ],\n\t\t\t\t\tindex,\n\t\t\t\t\tformat\n\t\t\t\t);\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Determine the highest position the new format can be inserted at.\n\t\tlet position = +Infinity;\n\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tif ( newFormats[ index ] ) {\n\t\t\t\tnewFormats[ index ] = newFormats[ index ].filter(\n\t\t\t\t\t( { type } ) => type !== format.type\n\t\t\t\t);\n\n\t\t\t\tconst length = newFormats[ index ].length;\n\n\t\t\t\tif ( length < position ) {\n\t\t\t\t\tposition = length;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewFormats[ index ] = [];\n\t\t\t\tposition = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tnewFormats[ index ].splice( position, 0, format );\n\t\t}\n\t}\n\n\treturn normaliseFormats( {\n\t\t...value,\n\t\tformats: newFormats,\n\t\t// Always revise active formats. This serves as a placeholder for new\n\t\t// inputs with the format so new input appears with the format applied,\n\t\t// and ensures a format of the same type uses the latest values.\n\t\tactiveFormats: [\n\t\t\t...( activeFormats?.filter(\n\t\t\t\t( { type } ) => type !== format.type\n\t\t\t) || [] ),\n\t\t\tformat,\n\t\t],\n\t} );\n}\n"],
  "mappings": ";AAIA,SAAS,wBAAwB;AAKjC,SAAS,QAAS,OAAO,OAAO,OAAQ;AACvC,UAAQ,MAAM,MAAM;AACpB,QAAO,KAAM,IAAI;AACjB,SAAO;AACR;AAcO,SAAS,YACf,OACA,QACA,aAAa,MAAM,OACnB,WAAW,MAAM,KAChB;AACD,QAAM,EAAE,SAAS,cAAc,IAAI;AACnC,QAAM,aAAa,QAAQ,MAAM;AAGjC,MAAK,eAAe,UAAW;AAC9B,UAAM,cAAc,WAAY,UAAW,GAAG;AAAA,MAC7C,CAAE,EAAE,KAAK,MAAO,SAAS,OAAO;AAAA,IACjC;AAIA,QAAK,aAAc;AAClB,YAAM,QAAQ,WAAY,UAAW,EAAE,QAAS,WAAY;AAE5D,aACC,WAAY,UAAW,KACvB,WAAY,UAAW,EAAG,KAAM,MAAM,aACrC;AACD,mBAAY,UAAW,IAAI;AAAA,UAC1B,WAAY,UAAW;AAAA,UACvB;AAAA,UACA;AAAA,QACD;AACA;AAAA,MACD;AAEA;AAEA,aACC,WAAY,QAAS,KACrB,WAAY,QAAS,EAAG,KAAM,MAAM,aACnC;AACD,mBAAY,QAAS,IAAI;AAAA,UACxB,WAAY,QAAS;AAAA,UACrB;AAAA,UACA;AAAA,QACD;AACA;AAAA,MACD;AAAA,IACD;AAAA,EACD,OAAO;AAEN,QAAI,WAAW;AAEf,aAAU,QAAQ,YAAY,QAAQ,UAAU,SAAU;AACzD,UAAK,WAAY,KAAM,GAAI;AAC1B,mBAAY,KAAM,IAAI,WAAY,KAAM,EAAE;AAAA,UACzC,CAAE,EAAE,KAAK,MAAO,SAAS,OAAO;AAAA,QACjC;AAEA,cAAM,SAAS,WAAY,KAAM,EAAE;AAEnC,YAAK,SAAS,UAAW;AACxB,qBAAW;AAAA,QACZ;AAAA,MACD,OAAO;AACN,mBAAY,KAAM,IAAI,CAAC;AACvB,mBAAW;AAAA,MACZ;AAAA,IACD;AAEA,aAAU,QAAQ,YAAY,QAAQ,UAAU,SAAU;AACzD,iBAAY,KAAM,EAAE,OAAQ,UAAU,GAAG,MAAO;AAAA,IACjD;AAAA,EACD;AAEA,SAAO,iBAAkB;AAAA,IACxB,GAAG;AAAA,IACH,SAAS;AAAA;AAAA;AAAA;AAAA,IAIT,eAAe;AAAA,MACd,GAAK,eAAe;AAAA,QACnB,CAAE,EAAE,KAAK,MAAO,SAAS,OAAO;AAAA,MACjC,KAAK,CAAC;AAAA,MACN;AAAA,IACD;AAAA,EACD,CAAE;AACH;",
  "names": []
}
