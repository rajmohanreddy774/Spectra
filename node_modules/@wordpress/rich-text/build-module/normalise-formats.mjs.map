{
  "version": 3,
  "sources": ["../src/normalise-formats.js"],
  "sourcesContent": ["/**\n * Internal dependencies\n */\n\nimport { isFormatEqual } from './is-format-equal';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Normalises formats: ensures subsequent adjacent equal formats have the same\n * reference.\n *\n * @param {RichTextValue} value Value to normalise formats of.\n *\n * @return {RichTextValue} New value with normalised formats.\n */\nexport function normaliseFormats( value ) {\n\tconst newFormats = value.formats.slice();\n\n\tnewFormats.forEach( ( formatsAtIndex, index ) => {\n\t\tconst formatsAtPreviousIndex = newFormats[ index - 1 ];\n\n\t\tif ( formatsAtPreviousIndex ) {\n\t\t\tconst newFormatsAtIndex = formatsAtIndex.slice();\n\n\t\t\tnewFormatsAtIndex.forEach( ( format, formatIndex ) => {\n\t\t\t\tconst previousFormat = formatsAtPreviousIndex[ formatIndex ];\n\n\t\t\t\tif ( isFormatEqual( format, previousFormat ) ) {\n\t\t\t\t\tnewFormatsAtIndex[ formatIndex ] = previousFormat;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tnewFormats[ index ] = newFormatsAtIndex;\n\t\t}\n\t} );\n\n\treturn {\n\t\t...value,\n\t\tformats: newFormats,\n\t};\n}\n"],
  "mappings": ";AAIA,SAAS,qBAAqB;AAYvB,SAAS,iBAAkB,OAAQ;AACzC,QAAM,aAAa,MAAM,QAAQ,MAAM;AAEvC,aAAW,QAAS,CAAE,gBAAgB,UAAW;AAChD,UAAM,yBAAyB,WAAY,QAAQ,CAAE;AAErD,QAAK,wBAAyB;AAC7B,YAAM,oBAAoB,eAAe,MAAM;AAE/C,wBAAkB,QAAS,CAAE,QAAQ,gBAAiB;AACrD,cAAM,iBAAiB,uBAAwB,WAAY;AAE3D,YAAK,cAAe,QAAQ,cAAe,GAAI;AAC9C,4BAAmB,WAAY,IAAI;AAAA,QACpC;AAAA,MACD,CAAE;AAEF,iBAAY,KAAM,IAAI;AAAA,IACvB;AAAA,EACD,CAAE;AAEF,SAAO;AAAA,IACN,GAAG;AAAA,IACH,SAAS;AAAA,EACV;AACD;",
  "names": []
}
