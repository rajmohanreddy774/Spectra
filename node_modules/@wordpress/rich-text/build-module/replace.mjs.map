{
  "version": 3,
  "sources": ["../src/replace.js"],
  "sourcesContent": ["/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Search a Rich Text value and replace the match(es) with `replacement`. This\n * is similar to `String.prototype.replace`.\n *\n * @param {RichTextValue}   value       The value to modify.\n * @param {RegExp|string}   pattern     A RegExp object or literal. Can also be\n *                                      a string. It is treated as a verbatim\n *                                      string and is not interpreted as a\n *                                      regular expression. Only the first\n *                                      occurrence will be replaced.\n * @param {Function|string} replacement The match or matches are replaced with\n *                                      the specified or the value returned by\n *                                      the specified function.\n *\n * @return {RichTextValue} A new value with replacements applied.\n */\nexport function replace(\n\t{ formats, replacements, text, start, end },\n\tpattern,\n\treplacement\n) {\n\ttext = text.replace( pattern, ( match, ...rest ) => {\n\t\tconst offset = rest[ rest.length - 2 ];\n\t\tlet newText = replacement;\n\t\tlet newFormats;\n\t\tlet newReplacements;\n\n\t\tif ( typeof newText === 'function' ) {\n\t\t\tnewText = replacement( match, ...rest );\n\t\t}\n\n\t\tif ( typeof newText === 'object' ) {\n\t\t\tnewFormats = newText.formats;\n\t\t\tnewReplacements = newText.replacements;\n\t\t\tnewText = newText.text;\n\t\t} else {\n\t\t\tnewFormats = Array( newText.length );\n\t\t\tnewReplacements = Array( newText.length );\n\n\t\t\tif ( formats[ offset ] ) {\n\t\t\t\tnewFormats = newFormats.fill( formats[ offset ] );\n\t\t\t}\n\t\t}\n\n\t\tformats = formats\n\t\t\t.slice( 0, offset )\n\t\t\t.concat( newFormats, formats.slice( offset + match.length ) );\n\t\treplacements = replacements\n\t\t\t.slice( 0, offset )\n\t\t\t.concat(\n\t\t\t\tnewReplacements,\n\t\t\t\treplacements.slice( offset + match.length )\n\t\t\t);\n\n\t\tif ( start ) {\n\t\t\tstart = end = offset + newText.length;\n\t\t}\n\n\t\treturn newText;\n\t} );\n\n\treturn normaliseFormats( { formats, replacements, text, start, end } );\n}\n"],
  "mappings": ";AAIA,SAAS,wBAAwB;AAoB1B,SAAS,QACf,EAAE,SAAS,cAAc,MAAM,OAAO,IAAI,GAC1C,SACA,aACC;AACD,SAAO,KAAK,QAAS,SAAS,CAAE,UAAU,SAAU;AACnD,UAAM,SAAS,KAAM,KAAK,SAAS,CAAE;AACrC,QAAI,UAAU;AACd,QAAI;AACJ,QAAI;AAEJ,QAAK,OAAO,YAAY,YAAa;AACpC,gBAAU,YAAa,OAAO,GAAG,IAAK;AAAA,IACvC;AAEA,QAAK,OAAO,YAAY,UAAW;AAClC,mBAAa,QAAQ;AACrB,wBAAkB,QAAQ;AAC1B,gBAAU,QAAQ;AAAA,IACnB,OAAO;AACN,mBAAa,MAAO,QAAQ,MAAO;AACnC,wBAAkB,MAAO,QAAQ,MAAO;AAExC,UAAK,QAAS,MAAO,GAAI;AACxB,qBAAa,WAAW,KAAM,QAAS,MAAO,CAAE;AAAA,MACjD;AAAA,IACD;AAEA,cAAU,QACR,MAAO,GAAG,MAAO,EACjB,OAAQ,YAAY,QAAQ,MAAO,SAAS,MAAM,MAAO,CAAE;AAC7D,mBAAe,aACb,MAAO,GAAG,MAAO,EACjB;AAAA,MACA;AAAA,MACA,aAAa,MAAO,SAAS,MAAM,MAAO;AAAA,IAC3C;AAED,QAAK,OAAQ;AACZ,cAAQ,MAAM,SAAS,QAAQ;AAAA,IAChC;AAEA,WAAO;AAAA,EACR,CAAE;AAEF,SAAO,iBAAkB,EAAE,SAAS,cAAc,MAAM,OAAO,IAAI,CAAE;AACtE;",
  "names": []
}
