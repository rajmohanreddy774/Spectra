{
  "version": 3,
  "sources": ["../src/remove-format.js"],
  "sourcesContent": ["/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Remove any format object from a Rich Text value by type from the given\n * `startIndex` to the given `endIndex`. Indices are retrieved from the\n * selection if none are provided.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {string}        formatType   Format type to remove.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the format applied.\n */\nexport function removeFormat(\n\tvalue,\n\tformatType,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, activeFormats } = value;\n\tconst newFormats = formats.slice();\n\n\t// If the selection is collapsed, expand start and end to the edges of the\n\t// format.\n\tif ( startIndex === endIndex ) {\n\t\tconst format = newFormats[ startIndex ]?.find(\n\t\t\t( { type } ) => type === formatType\n\t\t);\n\n\t\tif ( format ) {\n\t\t\twhile (\n\t\t\t\tnewFormats[ startIndex ]?.find(\n\t\t\t\t\t( newFormat ) => newFormat === format\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tfilterFormats( newFormats, startIndex, formatType );\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ endIndex ]?.find(\n\t\t\t\t\t( newFormat ) => newFormat === format\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tfilterFormats( newFormats, endIndex, formatType );\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor ( let i = startIndex; i < endIndex; i++ ) {\n\t\t\tif ( newFormats[ i ] ) {\n\t\t\t\tfilterFormats( newFormats, i, formatType );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn normaliseFormats( {\n\t\t...value,\n\t\tformats: newFormats,\n\t\tactiveFormats:\n\t\t\tactiveFormats?.filter( ( { type } ) => type !== formatType ) || [],\n\t} );\n}\n\nfunction filterFormats( formats, index, formatType ) {\n\tconst newFormats = formats[ index ].filter(\n\t\t( { type } ) => type !== formatType\n\t);\n\n\tif ( newFormats.length ) {\n\t\tformats[ index ] = newFormats;\n\t} else {\n\t\tdelete formats[ index ];\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA,+BAAiC;AAgB1B,SAAS,aACf,OACA,YACA,aAAa,MAAM,OACnB,WAAW,MAAM,KAChB;AACD,QAAM,EAAE,SAAS,cAAc,IAAI;AACnC,QAAM,aAAa,QAAQ,MAAM;AAIjC,MAAK,eAAe,UAAW;AAC9B,UAAM,SAAS,WAAY,UAAW,GAAG;AAAA,MACxC,CAAE,EAAE,KAAK,MAAO,SAAS;AAAA,IAC1B;AAEA,QAAK,QAAS;AACb,aACC,WAAY,UAAW,GAAG;AAAA,QACzB,CAAE,cAAe,cAAc;AAAA,MAChC,GACC;AACD,sBAAe,YAAY,YAAY,UAAW;AAClD;AAAA,MACD;AAEA;AAEA,aACC,WAAY,QAAS,GAAG;AAAA,QACvB,CAAE,cAAe,cAAc;AAAA,MAChC,GACC;AACD,sBAAe,YAAY,UAAU,UAAW;AAChD;AAAA,MACD;AAAA,IACD;AAAA,EACD,OAAO;AACN,aAAU,IAAI,YAAY,IAAI,UAAU,KAAM;AAC7C,UAAK,WAAY,CAAE,GAAI;AACtB,sBAAe,YAAY,GAAG,UAAW;AAAA,MAC1C;AAAA,IACD;AAAA,EACD;AAEA,aAAO,2CAAkB;AAAA,IACxB,GAAG;AAAA,IACH,SAAS;AAAA,IACT,eACC,eAAe,OAAQ,CAAE,EAAE,KAAK,MAAO,SAAS,UAAW,KAAK,CAAC;AAAA,EACnE,CAAE;AACH;AAEA,SAAS,cAAe,SAAS,OAAO,YAAa;AACpD,QAAM,aAAa,QAAS,KAAM,EAAE;AAAA,IACnC,CAAE,EAAE,KAAK,MAAO,SAAS;AAAA,EAC1B;AAEA,MAAK,WAAW,QAAS;AACxB,YAAS,KAAM,IAAI;AAAA,EACpB,OAAO;AACN,WAAO,QAAS,KAAM;AAAA,EACvB;AACD;",
  "names": []
}
