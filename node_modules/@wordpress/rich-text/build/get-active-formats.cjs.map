{
  "version": 3,
  "sources": ["../src/get-active-formats.js"],
  "sourcesContent": ["/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormatList} RichTextFormatList */\n\n/**\n * Internal dependencies\n */\nimport { isFormatEqual } from './is-format-equal';\n\n/**\n * Gets the all format objects at the start of the selection.\n *\n * @param {RichTextValue} value                Value to inspect.\n * @param {Array}         EMPTY_ACTIVE_FORMATS Array to return if there are no\n *                                             active formats.\n *\n * @return {RichTextFormatList} Active format objects.\n */\nexport function getActiveFormats( value, EMPTY_ACTIVE_FORMATS = [] ) {\n\tconst { formats, start, end, activeFormats } = value;\n\tif ( start === undefined ) {\n\t\treturn EMPTY_ACTIVE_FORMATS;\n\t}\n\n\tif ( start === end ) {\n\t\t// For a collapsed caret, it is possible to override the active formats.\n\t\tif ( activeFormats ) {\n\t\t\treturn activeFormats;\n\t\t}\n\n\t\tconst formatsBefore = formats[ start - 1 ] || EMPTY_ACTIVE_FORMATS;\n\t\tconst formatsAfter = formats[ start ] || EMPTY_ACTIVE_FORMATS;\n\n\t\t// By default, select the lowest amount of formats possible (which means\n\t\t// the caret is positioned outside the format boundary). The user can\n\t\t// then use arrow keys to define `activeFormats`.\n\t\tif ( formatsBefore.length < formatsAfter.length ) {\n\t\t\treturn formatsBefore;\n\t\t}\n\n\t\treturn formatsAfter;\n\t}\n\n\t// If there's no formats at the start index, there are not active formats.\n\tif ( ! formats[ start ] ) {\n\t\treturn EMPTY_ACTIVE_FORMATS;\n\t}\n\n\tconst selectedFormats = formats.slice( start, end );\n\n\t// Clone the formats so we're not mutating the live value.\n\tconst _activeFormats = [ ...selectedFormats[ 0 ] ];\n\tlet i = selectedFormats.length;\n\n\t// For performance reasons, start from the end where it's much quicker to\n\t// realise that there are no active formats.\n\twhile ( i-- ) {\n\t\tconst formatsAtIndex = selectedFormats[ i ];\n\n\t\t// If we run into any index without formats, we're sure that there's no\n\t\t// active formats.\n\t\tif ( ! formatsAtIndex ) {\n\t\t\treturn EMPTY_ACTIVE_FORMATS;\n\t\t}\n\n\t\tlet ii = _activeFormats.length;\n\n\t\t// Loop over the active formats and remove any that are not present at\n\t\t// the current index.\n\t\twhile ( ii-- ) {\n\t\t\tconst format = _activeFormats[ ii ];\n\n\t\t\tif (\n\t\t\t\t! formatsAtIndex.find( ( _format ) =>\n\t\t\t\t\tisFormatEqual( format, _format )\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t_activeFormats.splice( ii, 1 );\n\t\t\t}\n\t\t}\n\n\t\t// If there are no active formats, we can stop.\n\t\tif ( _activeFormats.length === 0 ) {\n\t\t\treturn EMPTY_ACTIVE_FORMATS;\n\t\t}\n\t}\n\n\treturn _activeFormats || EMPTY_ACTIVE_FORMATS;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,6BAA8B;AAWvB,SAAS,iBAAkB,OAAO,uBAAuB,CAAC,GAAI;AACpE,QAAM,EAAE,SAAS,OAAO,KAAK,cAAc,IAAI;AAC/C,MAAK,UAAU,QAAY;AAC1B,WAAO;AAAA,EACR;AAEA,MAAK,UAAU,KAAM;AAEpB,QAAK,eAAgB;AACpB,aAAO;AAAA,IACR;AAEA,UAAM,gBAAgB,QAAS,QAAQ,CAAE,KAAK;AAC9C,UAAM,eAAe,QAAS,KAAM,KAAK;AAKzC,QAAK,cAAc,SAAS,aAAa,QAAS;AACjD,aAAO;AAAA,IACR;AAEA,WAAO;AAAA,EACR;AAGA,MAAK,CAAE,QAAS,KAAM,GAAI;AACzB,WAAO;AAAA,EACR;AAEA,QAAM,kBAAkB,QAAQ,MAAO,OAAO,GAAI;AAGlD,QAAM,iBAAiB,CAAE,GAAG,gBAAiB,CAAE,CAAE;AACjD,MAAI,IAAI,gBAAgB;AAIxB,SAAQ,KAAM;AACb,UAAM,iBAAiB,gBAAiB,CAAE;AAI1C,QAAK,CAAE,gBAAiB;AACvB,aAAO;AAAA,IACR;AAEA,QAAI,KAAK,eAAe;AAIxB,WAAQ,MAAO;AACd,YAAM,SAAS,eAAgB,EAAG;AAElC,UACC,CAAE,eAAe;AAAA,QAAM,CAAE,gBACxB,sCAAe,QAAQ,OAAQ;AAAA,MAChC,GACC;AACD,uBAAe,OAAQ,IAAI,CAAE;AAAA,MAC9B;AAAA,IACD;AAGA,QAAK,eAAe,WAAW,GAAI;AAClC,aAAO;AAAA,IACR;AAAA,EACD;AAEA,SAAO,kBAAkB;AAC1B;",
  "names": []
}
