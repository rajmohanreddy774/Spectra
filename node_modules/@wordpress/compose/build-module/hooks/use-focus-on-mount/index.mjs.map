{
  "version": 3,
  "sources": ["../../../src/hooks/use-focus-on-mount/index.js"],
  "sourcesContent": ["/**\n * WordPress dependencies\n */\nimport { useRef, useEffect } from '@wordpress/element';\nimport { focus } from '@wordpress/dom';\n\n/**\n * Internal dependencies\n */\nimport useRefEffect from '../use-ref-effect';\n\n/**\n * Hook used to focus the first tabbable element on mount.\n *\n * @param {boolean | 'firstElement' | 'firstInputElement'} focusOnMount Focus on mount mode.\n * @return {import('react').RefCallback<HTMLElement>} Ref callback.\n *\n * @example\n * ```js\n * import { useFocusOnMount } from '@wordpress/compose';\n *\n * const WithFocusOnMount = () => {\n *     const ref = useFocusOnMount()\n *     return (\n *         <div ref={ ref }>\n *             <Button />\n *             <Button />\n *         </div>\n *     );\n * }\n * ```\n */\nexport default function useFocusOnMount( focusOnMount = 'firstElement' ) {\n\tconst focusOnMountRef = useRef( focusOnMount );\n\n\t/**\n\t * Sets focus on a DOM element.\n\t *\n\t * @param {HTMLElement} target The DOM element to set focus to.\n\t * @return {void}\n\t */\n\tconst setFocus = ( target ) => {\n\t\ttarget.focus( {\n\t\t\t// When focusing newly mounted dialogs,\n\t\t\t// the position of the popover is often not right on the first render\n\t\t\t// This prevents the layout shifts when focusing the dialogs.\n\t\t\tpreventScroll: true,\n\t\t} );\n\t};\n\n\t/** @type {import('react').MutableRefObject<ReturnType<setTimeout> | undefined>} */\n\tconst timerIdRef = useRef();\n\n\tuseEffect( () => {\n\t\tfocusOnMountRef.current = focusOnMount;\n\t}, [ focusOnMount ] );\n\n\treturn useRefEffect( ( node ) => {\n\t\tif ( ! node || focusOnMountRef.current === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( node.contains( node.ownerDocument?.activeElement ?? null ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tfocusOnMountRef.current !== 'firstElement' &&\n\t\t\tfocusOnMountRef.current !== 'firstInputElement'\n\t\t) {\n\t\t\tsetFocus( node );\n\t\t\treturn;\n\t\t}\n\n\t\ttimerIdRef.current = setTimeout( () => {\n\t\t\t// For 'firstInputElement' mode, try to find a form input element first\n\t\t\tif ( focusOnMountRef.current === 'firstInputElement' ) {\n\t\t\t\t/** @type {HTMLElement | null} */\n\t\t\t\tlet formInput = null;\n\t\t\t\tif (\n\t\t\t\t\ttypeof window !== 'undefined' &&\n\t\t\t\t\tnode instanceof window.Element\n\t\t\t\t) {\n\t\t\t\t\tformInput = node.querySelector(\n\t\t\t\t\t\t'input:not([type=\"hidden\"]):not([disabled]), select:not([disabled]), textarea:not([disabled])'\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif ( formInput ) {\n\t\t\t\t\tsetFocus( formInput );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fallback to the first tabbable element\n\t\t\tconst firstTabbable = focus.tabbable.find( node )[ 0 ];\n\t\t\tif ( firstTabbable ) {\n\t\t\t\tsetFocus( firstTabbable );\n\t\t\t}\n\t\t}, 0 );\n\n\t\treturn () => {\n\t\t\tif ( timerIdRef.current ) {\n\t\t\t\tclearTimeout( timerIdRef.current );\n\t\t\t}\n\t\t};\n\t}, [] );\n}\n"],
  "mappings": ";AAGA,SAAS,QAAQ,iBAAiB;AAClC,SAAS,aAAa;AAKtB,OAAO,kBAAkB;AAuBV,SAAR,gBAAkC,eAAe,gBAAiB;AACxE,QAAM,kBAAkB,OAAQ,YAAa;AAQ7C,QAAM,WAAW,CAAE,WAAY;AAC9B,WAAO,MAAO;AAAA;AAAA;AAAA;AAAA,MAIb,eAAe;AAAA,IAChB,CAAE;AAAA,EACH;AAGA,QAAM,aAAa,OAAO;AAE1B,YAAW,MAAM;AAChB,oBAAgB,UAAU;AAAA,EAC3B,GAAG,CAAE,YAAa,CAAE;AAEpB,SAAO,aAAc,CAAE,SAAU;AAChC,QAAK,CAAE,QAAQ,gBAAgB,YAAY,OAAQ;AAClD;AAAA,IACD;AAEA,QAAK,KAAK,SAAU,KAAK,eAAe,iBAAiB,IAAK,GAAI;AACjE;AAAA,IACD;AAEA,QACC,gBAAgB,YAAY,kBAC5B,gBAAgB,YAAY,qBAC3B;AACD,eAAU,IAAK;AACf;AAAA,IACD;AAEA,eAAW,UAAU,WAAY,MAAM;AAEtC,UAAK,gBAAgB,YAAY,qBAAsB;AAEtD,YAAI,YAAY;AAChB,YACC,OAAO,WAAW,eAClB,gBAAgB,OAAO,SACtB;AACD,sBAAY,KAAK;AAAA,YAChB;AAAA,UACD;AAAA,QACD;AAEA,YAAK,WAAY;AAChB,mBAAU,SAAU;AACpB;AAAA,QACD;AAAA,MACD;AAGA,YAAM,gBAAgB,MAAM,SAAS,KAAM,IAAK,EAAG,CAAE;AACrD,UAAK,eAAgB;AACpB,iBAAU,aAAc;AAAA,MACzB;AAAA,IACD,GAAG,CAAE;AAEL,WAAO,MAAM;AACZ,UAAK,WAAW,SAAU;AACzB,qBAAc,WAAW,OAAQ;AAAA,MAClC;AAAA,IACD;AAAA,EACD,GAAG,CAAC,CAAE;AACP;",
  "names": []
}
