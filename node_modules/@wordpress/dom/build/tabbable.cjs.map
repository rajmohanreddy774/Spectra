{
  "version": 3,
  "sources": ["../src/tabbable.js"],
  "sourcesContent": ["/**\n * Internal dependencies\n */\nimport { find as findFocusable } from './focusable';\n\n/**\n * Returns the tab index of the given element. In contrast with the tabIndex\n * property, this normalizes the default (0) to avoid browser inconsistencies,\n * operating under the assumption that this function is only ever called with a\n * focusable node.\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1190261\n *\n * @param {Element} element Element from which to retrieve.\n *\n * @return {number} Tab index of element (default 0).\n */\nfunction getTabIndex( element ) {\n\tconst tabIndex = element.getAttribute( 'tabindex' );\n\treturn tabIndex === null ? 0 : parseInt( tabIndex, 10 );\n}\n\n/**\n * Returns true if the specified element is tabbable, or false otherwise.\n *\n * @param {Element} element Element to test.\n *\n * @return {boolean} Whether element is tabbable.\n */\nexport function isTabbableIndex( element ) {\n\treturn getTabIndex( element ) !== -1;\n}\n\n/** @typedef {HTMLElement & { type?: string, checked?: boolean, name?: string }} MaybeHTMLInputElement */\n\n/**\n * Returns a stateful reducer function which constructs a filtered array of\n * tabbable elements, where at most one radio input is selected for a given\n * name, giving priority to checked input, falling back to the first\n * encountered.\n *\n * @return {(acc: MaybeHTMLInputElement[], el: MaybeHTMLInputElement) => MaybeHTMLInputElement[]} Radio group collapse reducer.\n */\nfunction createStatefulCollapseRadioGroup() {\n\t/** @type {Record<string, MaybeHTMLInputElement>} */\n\tconst CHOSEN_RADIO_BY_NAME = {};\n\n\treturn function collapseRadioGroup(\n\t\t/** @type {MaybeHTMLInputElement[]} */ result,\n\t\t/** @type {MaybeHTMLInputElement} */ element\n\t) {\n\t\tconst { nodeName, type, checked, name } = element;\n\n\t\t// For all non-radio tabbables, construct to array by concatenating.\n\t\tif ( nodeName !== 'INPUT' || type !== 'radio' || ! name ) {\n\t\t\treturn result.concat( element );\n\t\t}\n\n\t\tconst hasChosen = CHOSEN_RADIO_BY_NAME.hasOwnProperty( name );\n\n\t\t// Omit by skipping concatenation if the radio element is not chosen.\n\t\tconst isChosen = checked || ! hasChosen;\n\t\tif ( ! isChosen ) {\n\t\t\treturn result;\n\t\t}\n\n\t\t// At this point, if there had been a chosen element, the current\n\t\t// element is checked and should take priority. Retroactively remove\n\t\t// the element which had previously been considered the chosen one.\n\t\tif ( hasChosen ) {\n\t\t\tconst hadChosenElement = CHOSEN_RADIO_BY_NAME[ name ];\n\t\t\tresult = result.filter( ( e ) => e !== hadChosenElement );\n\t\t}\n\n\t\tCHOSEN_RADIO_BY_NAME[ name ] = element;\n\n\t\treturn result.concat( element );\n\t};\n}\n\n/**\n * An array map callback, returning an object with the element value and its\n * array index location as properties. This is used to emulate a proper stable\n * sort where equal tabIndex should be left in order of their occurrence in the\n * document.\n *\n * @param {HTMLElement} element Element.\n * @param {number}      index   Array index of element.\n *\n * @return {{ element: HTMLElement, index: number }} Mapped object with element, index.\n */\nfunction mapElementToObjectTabbable( element, index ) {\n\treturn { element, index };\n}\n\n/**\n * An array map callback, returning an element of the given mapped object's\n * element value.\n *\n * @param {{ element: HTMLElement }} object Mapped object with element.\n *\n * @return {HTMLElement} Mapped object element.\n */\nfunction mapObjectTabbableToElement( object ) {\n\treturn object.element;\n}\n\n/**\n * A sort comparator function used in comparing two objects of mapped elements.\n *\n * @see mapElementToObjectTabbable\n *\n * @param {{ element: HTMLElement, index: number }} a First object to compare.\n * @param {{ element: HTMLElement, index: number }} b Second object to compare.\n *\n * @return {number} Comparator result.\n */\nfunction compareObjectTabbables( a, b ) {\n\tconst aTabIndex = getTabIndex( a.element );\n\tconst bTabIndex = getTabIndex( b.element );\n\n\tif ( aTabIndex === bTabIndex ) {\n\t\treturn a.index - b.index;\n\t}\n\n\treturn aTabIndex - bTabIndex;\n}\n\n/**\n * Givin focusable elements, filters out tabbable element.\n *\n * @param {HTMLElement[]} focusables Focusable elements to filter.\n *\n * @return {HTMLElement[]} Tabbable elements.\n */\nfunction filterTabbable( focusables ) {\n\treturn focusables\n\t\t.filter( isTabbableIndex )\n\t\t.map( mapElementToObjectTabbable )\n\t\t.sort( compareObjectTabbables )\n\t\t.map( mapObjectTabbableToElement )\n\t\t.reduce( createStatefulCollapseRadioGroup(), [] );\n}\n\n/**\n * @param {Element} context\n * @return {HTMLElement[]} Tabbable elements within the context.\n */\nexport function find( context ) {\n\treturn filterTabbable( findFocusable( context ) );\n}\n\n/**\n * Given a focusable element, find the preceding tabbable element.\n *\n * @param {Element} element The focusable element before which to look. Defaults\n *                          to the active element.\n *\n * @return {HTMLElement|undefined} Preceding tabbable element.\n */\nexport function findPrevious( element ) {\n\treturn filterTabbable( findFocusable( element.ownerDocument.body ) )\n\t\t.reverse()\n\t\t.find(\n\t\t\t( focusable ) =>\n\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\telement.compareDocumentPosition( focusable ) &\n\t\t\t\telement.DOCUMENT_POSITION_PRECEDING\n\t\t);\n}\n\n/**\n * Given a focusable element, find the next tabbable element.\n *\n * @param {Element} element The focusable element after which to look. Defaults\n *                          to the active element.\n *\n * @return {HTMLElement|undefined} Next tabbable element.\n */\nexport function findNext( element ) {\n\treturn filterTabbable( findFocusable( element.ownerDocument.body ) ).find(\n\t\t( focusable ) =>\n\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\telement.compareDocumentPosition( focusable ) &\n\t\t\telement.DOCUMENT_POSITION_FOLLOWING\n\t);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,uBAAsC;AActC,SAAS,YAAa,SAAU;AAC/B,QAAM,WAAW,QAAQ,aAAc,UAAW;AAClD,SAAO,aAAa,OAAO,IAAI,SAAU,UAAU,EAAG;AACvD;AASO,SAAS,gBAAiB,SAAU;AAC1C,SAAO,YAAa,OAAQ,MAAM;AACnC;AAYA,SAAS,mCAAmC;AAE3C,QAAM,uBAAuB,CAAC;AAE9B,SAAO,SAAS,mBACwB,QACF,SACpC;AACD,UAAM,EAAE,UAAU,MAAM,SAAS,KAAK,IAAI;AAG1C,QAAK,aAAa,WAAW,SAAS,WAAW,CAAE,MAAO;AACzD,aAAO,OAAO,OAAQ,OAAQ;AAAA,IAC/B;AAEA,UAAM,YAAY,qBAAqB,eAAgB,IAAK;AAG5D,UAAM,WAAW,WAAW,CAAE;AAC9B,QAAK,CAAE,UAAW;AACjB,aAAO;AAAA,IACR;AAKA,QAAK,WAAY;AAChB,YAAM,mBAAmB,qBAAsB,IAAK;AACpD,eAAS,OAAO,OAAQ,CAAE,MAAO,MAAM,gBAAiB;AAAA,IACzD;AAEA,yBAAsB,IAAK,IAAI;AAE/B,WAAO,OAAO,OAAQ,OAAQ;AAAA,EAC/B;AACD;AAaA,SAAS,2BAA4B,SAAS,OAAQ;AACrD,SAAO,EAAE,SAAS,MAAM;AACzB;AAUA,SAAS,2BAA4B,QAAS;AAC7C,SAAO,OAAO;AACf;AAYA,SAAS,uBAAwB,GAAG,GAAI;AACvC,QAAM,YAAY,YAAa,EAAE,OAAQ;AACzC,QAAM,YAAY,YAAa,EAAE,OAAQ;AAEzC,MAAK,cAAc,WAAY;AAC9B,WAAO,EAAE,QAAQ,EAAE;AAAA,EACpB;AAEA,SAAO,YAAY;AACpB;AASA,SAAS,eAAgB,YAAa;AACrC,SAAO,WACL,OAAQ,eAAgB,EACxB,IAAK,0BAA2B,EAChC,KAAM,sBAAuB,EAC7B,IAAK,0BAA2B,EAChC,OAAQ,iCAAiC,GAAG,CAAC,CAAE;AAClD;AAMO,SAAS,KAAM,SAAU;AAC/B,SAAO,mBAAgB,iBAAAA,MAAe,OAAQ,CAAE;AACjD;AAUO,SAAS,aAAc,SAAU;AACvC,SAAO,mBAAgB,iBAAAA,MAAe,QAAQ,cAAc,IAAK,CAAE,EACjE,QAAQ,EACR;AAAA,IACA,CAAE;AAAA;AAAA,MAED,QAAQ,wBAAyB,SAAU,IAC3C,QAAQ;AAAA;AAAA,EACV;AACF;AAUO,SAAS,SAAU,SAAU;AACnC,SAAO,mBAAgB,iBAAAA,MAAe,QAAQ,cAAc,IAAK,CAAE,EAAE;AAAA,IACpE,CAAE;AAAA;AAAA,MAED,QAAQ,wBAAyB,SAAU,IAC3C,QAAQ;AAAA;AAAA,EACV;AACD;",
  "names": ["findFocusable"]
}
