{
  "version": 3,
  "sources": ["../../src/border-box-control/utils.ts"],
  "sourcesContent": ["/**\n * External dependencies\n */\n\n/**\n * Internal dependencies\n */\nimport { parseCSSUnitValue } from '../utils/unit-values';\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst borderProps = ['color', 'style', 'width'];\nexport const isEmptyBorder = border => {\n  if (!border) {\n    return true;\n  }\n  return !borderProps.some(prop => border[prop] !== undefined);\n};\nexport const isDefinedBorder = border => {\n  // No border, no worries :)\n  if (!border) {\n    return false;\n  }\n\n  // If we have individual borders per side within the border object we\n  // need to check whether any of those side borders have been set.\n  if (hasSplitBorders(border)) {\n    const allSidesEmpty = sides.every(side => isEmptyBorder(border[side]));\n    return !allSidesEmpty;\n  }\n\n  // If we have a top-level border only, check if that is empty. e.g.\n  // { color: undefined, style: undefined, width: undefined }\n  // Border radius can still be set within the border object as it is\n  // handled separately.\n  return !isEmptyBorder(border);\n};\nexport const isCompleteBorder = border => {\n  if (!border) {\n    return false;\n  }\n  return borderProps.every(prop => border[prop] !== undefined);\n};\nexport const hasSplitBorders = (border = {}) => {\n  return Object.keys(border).some(side => sides.indexOf(side) !== -1);\n};\nexport const hasMixedBorders = borders => {\n  if (!hasSplitBorders(borders)) {\n    return false;\n  }\n  const shorthandBorders = sides.map(side => getShorthandBorderStyle(borders?.[side]));\n  return !shorthandBorders.every(border => border === shorthandBorders[0]);\n};\nexport const getSplitBorders = border => {\n  if (!border || isEmptyBorder(border)) {\n    return undefined;\n  }\n  return {\n    top: border,\n    right: border,\n    bottom: border,\n    left: border\n  };\n};\nexport const getBorderDiff = (original, updated) => {\n  const diff = {};\n  if (original.color !== updated.color) {\n    diff.color = updated.color;\n  }\n  if (original.style !== updated.style) {\n    diff.style = updated.style;\n  }\n  if (original.width !== updated.width) {\n    diff.width = updated.width;\n  }\n  return diff;\n};\nexport const getCommonBorder = borders => {\n  if (!borders) {\n    return undefined;\n  }\n  const colors = [];\n  const styles = [];\n  const widths = [];\n  sides.forEach(side => {\n    colors.push(borders[side]?.color);\n    styles.push(borders[side]?.style);\n    widths.push(borders[side]?.width);\n  });\n  const allColorsMatch = colors.every(value => value === colors[0]);\n  const allStylesMatch = styles.every(value => value === styles[0]);\n  const allWidthsMatch = widths.every(value => value === widths[0]);\n  return {\n    color: allColorsMatch ? colors[0] : undefined,\n    style: allStylesMatch ? styles[0] : undefined,\n    width: allWidthsMatch ? widths[0] : getMostCommonUnit(widths)\n  };\n};\nexport const getShorthandBorderStyle = (border, fallbackBorder) => {\n  if (isEmptyBorder(border)) {\n    return fallbackBorder;\n  }\n  const {\n    color: fallbackColor,\n    style: fallbackStyle,\n    width: fallbackWidth\n  } = fallbackBorder || {};\n  const {\n    color = fallbackColor,\n    style = fallbackStyle,\n    width = fallbackWidth\n  } = border;\n  const hasVisibleBorder = !!width && width !== '0' || !!color;\n  const borderStyle = hasVisibleBorder ? style || 'solid' : style;\n  return [width, borderStyle, color].filter(Boolean).join(' ');\n};\nexport const getMostCommonUnit = values => {\n  // Collect all the CSS units.\n  const units = values.map(value => value === undefined ? undefined : parseCSSUnitValue(`${value}`)[1]);\n\n  // Return the most common unit out of only the defined CSS units.\n  const filteredUnits = units.filter(value => value !== undefined);\n  return mode(filteredUnits);\n};\n\n/**\n * Finds the mode value out of the array passed favouring the first value\n * as a tiebreaker.\n *\n * @param values Values to determine the mode from.\n *\n * @return The mode value.\n */\nfunction mode(values) {\n  if (values.length === 0) {\n    return undefined;\n  }\n  const map = {};\n  let maxCount = 0;\n  let currentMode;\n  values.forEach(value => {\n    map[value] = map[value] === undefined ? 1 : map[value] + 1;\n    if (map[value] > maxCount) {\n      currentMode = value;\n      maxCount = map[value];\n    }\n  });\n  return currentMode;\n}"],
  "mappings": "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",
  "names": []
}
