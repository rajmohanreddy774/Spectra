{
  "version": 3,
  "sources": ["../../../src/custom-gradient-picker/gradient-bar/utils.ts"],
  "sourcesContent": ["/**\n * Internal dependencies\n */\nimport { MINIMUM_DISTANCE_BETWEEN_POINTS } from './constants';\n/**\n * Clamps a number between 0 and 100.\n *\n * @param value Value to clamp.\n *\n * @return Value clamped between 0 and 100.\n */\nexport function clampPercent(value) {\n  return Math.max(0, Math.min(100, value));\n}\n\n/**\n * Check if a control point is overlapping with another.\n *\n * @param value        Array of control points.\n * @param initialIndex Index of the position to test.\n * @param newPosition  New position of the control point.\n * @param minDistance  Distance considered to be overlapping.\n *\n * @return True if the point is overlapping.\n */\nexport function isOverlapping(value, initialIndex, newPosition, minDistance = MINIMUM_DISTANCE_BETWEEN_POINTS) {\n  const initialPosition = value[initialIndex].position;\n  const minPosition = Math.min(initialPosition, newPosition);\n  const maxPosition = Math.max(initialPosition, newPosition);\n  return value.some(({\n    position\n  }, index) => {\n    return index !== initialIndex && (Math.abs(position - newPosition) < minDistance || minPosition < position && position < maxPosition);\n  });\n}\n\n/**\n * Adds a control point from an array and returns the new array.\n *\n * @param points   Array of control points.\n * @param position Position to insert the new point.\n * @param color    Color to update the control point at index.\n *\n * @return New array of control points.\n */\nexport function addControlPoint(points, position, color) {\n  const nextIndex = points.findIndex(point => point.position > position);\n  const newPoint = {\n    color,\n    position\n  };\n  const newPoints = points.slice();\n  newPoints.splice(nextIndex - 1, 0, newPoint);\n  return newPoints;\n}\n\n/**\n * Removes a control point from an array and returns the new array.\n *\n * @param points Array of control points.\n * @param index  Index to remove.\n *\n * @return New array of control points.\n */\nexport function removeControlPoint(points, index) {\n  return points.filter((_point, pointIndex) => {\n    return pointIndex !== index;\n  });\n}\n/**\n * Updates a control point from an array and returns the new array.\n *\n * @param points   Array of control points.\n * @param index    Index to update.\n * @param newPoint New control point to replace the index.\n *\n * @return New array of control points.\n */\nexport function updateControlPoint(points, index, newPoint) {\n  const newValue = points.slice();\n  newValue[index] = newPoint;\n  return newValue;\n}\n\n/**\n * Updates the position of a control point from an array and returns the new array.\n *\n * @param points      Array of control points.\n * @param index       Index to update.\n * @param newPosition Position to move the control point at index.\n *\n * @return New array of control points.\n */\nexport function updateControlPointPosition(points, index, newPosition) {\n  if (isOverlapping(points, index, newPosition)) {\n    return points;\n  }\n  const newPoint = {\n    ...points[index],\n    position: newPosition\n  };\n  return updateControlPoint(points, index, newPoint);\n}\n\n/**\n * Updates the position of a control point from an array and returns the new array.\n *\n * @param points   Array of control points.\n * @param index    Index to update.\n * @param newColor Color to update the control point at index.\n *\n * @return New array of control points.\n */\nexport function updateControlPointColor(points, index, newColor) {\n  const newPoint = {\n    ...points[index],\n    color: newColor\n  };\n  return updateControlPoint(points, index, newPoint);\n}\n\n/**\n * Updates the position of a control point from an array and returns the new array.\n *\n * @param points   Array of control points.\n * @param position Position of the color stop.\n * @param newColor Color to update the control point at index.\n *\n * @return New array of control points.\n */\nexport function updateControlPointColorByPosition(points, position, newColor) {\n  const index = points.findIndex(point => point.position === position);\n  return updateControlPointColor(points, index, newColor);\n}\n\n/**\n * Gets the horizontal coordinate when dragging a control point with the mouse.\n *\n * @param mouseXcoordinate Horizontal coordinate of the mouse position.\n * @param containerElement Container for the gradient picker.\n *\n * @return Whole number percentage from the left.\n */\n\nexport function getHorizontalRelativeGradientPosition(mouseXCoordinate, containerElement) {\n  if (!containerElement) {\n    return;\n  }\n  const {\n    x,\n    width\n  } = containerElement.getBoundingClientRect();\n  const absolutePositionValue = mouseXCoordinate - x;\n  return Math.round(clampPercent(absolutePositionValue * 100 / width));\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,uBAAgD;AAQzC,SAAS,aAAa,OAAO;AAClC,SAAO,KAAK,IAAI,GAAG,KAAK,IAAI,KAAK,KAAK,CAAC;AACzC;AAYO,SAAS,cAAc,OAAO,cAAc,aAAa,cAAc,kDAAiC;AAC7G,QAAM,kBAAkB,MAAM,YAAY,EAAE;AAC5C,QAAM,cAAc,KAAK,IAAI,iBAAiB,WAAW;AACzD,QAAM,cAAc,KAAK,IAAI,iBAAiB,WAAW;AACzD,SAAO,MAAM,KAAK,CAAC;AAAA,IACjB;AAAA,EACF,GAAG,UAAU;AACX,WAAO,UAAU,iBAAiB,KAAK,IAAI,WAAW,WAAW,IAAI,eAAe,cAAc,YAAY,WAAW;AAAA,EAC3H,CAAC;AACH;AAWO,SAAS,gBAAgB,QAAQ,UAAU,OAAO;AACvD,QAAM,YAAY,OAAO,UAAU,WAAS,MAAM,WAAW,QAAQ;AACrE,QAAM,WAAW;AAAA,IACf;AAAA,IACA;AAAA,EACF;AACA,QAAM,YAAY,OAAO,MAAM;AAC/B,YAAU,OAAO,YAAY,GAAG,GAAG,QAAQ;AAC3C,SAAO;AACT;AAUO,SAAS,mBAAmB,QAAQ,OAAO;AAChD,SAAO,OAAO,OAAO,CAAC,QAAQ,eAAe;AAC3C,WAAO,eAAe;AAAA,EACxB,CAAC;AACH;AAUO,SAAS,mBAAmB,QAAQ,OAAO,UAAU;AAC1D,QAAM,WAAW,OAAO,MAAM;AAC9B,WAAS,KAAK,IAAI;AAClB,SAAO;AACT;AAWO,SAAS,2BAA2B,QAAQ,OAAO,aAAa;AACrE,MAAI,cAAc,QAAQ,OAAO,WAAW,GAAG;AAC7C,WAAO;AAAA,EACT;AACA,QAAM,WAAW;AAAA,IACf,GAAG,OAAO,KAAK;AAAA,IACf,UAAU;AAAA,EACZ;AACA,SAAO,mBAAmB,QAAQ,OAAO,QAAQ;AACnD;AAWO,SAAS,wBAAwB,QAAQ,OAAO,UAAU;AAC/D,QAAM,WAAW;AAAA,IACf,GAAG,OAAO,KAAK;AAAA,IACf,OAAO;AAAA,EACT;AACA,SAAO,mBAAmB,QAAQ,OAAO,QAAQ;AACnD;AAWO,SAAS,kCAAkC,QAAQ,UAAU,UAAU;AAC5E,QAAM,QAAQ,OAAO,UAAU,WAAS,MAAM,aAAa,QAAQ;AACnE,SAAO,wBAAwB,QAAQ,OAAO,QAAQ;AACxD;AAWO,SAAS,sCAAsC,kBAAkB,kBAAkB;AACxF,MAAI,CAAC,kBAAkB;AACrB;AAAA,EACF;AACA,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,EACF,IAAI,iBAAiB,sBAAsB;AAC3C,QAAM,wBAAwB,mBAAmB;AACjD,SAAO,KAAK,MAAM,aAAa,wBAAwB,MAAM,KAAK,CAAC;AACrE;",
  "names": []
}
