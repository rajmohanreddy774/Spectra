{
  "version": 3,
  "sources": ["../../../src/higher-order/with-filters/index.tsx"],
  "sourcesContent": ["/**\n * WordPress dependencies\n */\nimport { Component } from '@wordpress/element';\nimport { addAction, applyFilters, removeAction } from '@wordpress/hooks';\nimport { createHigherOrderComponent, debounce } from '@wordpress/compose';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst ANIMATION_FRAME_PERIOD = 16;\n\n/**\n * Creates a higher-order component which adds filtering capability to the\n * wrapped component. Filters get applied when the original component is about\n * to be mounted. When a filter is added or removed that matches the hook name,\n * the wrapped component re-renders.\n *\n * @param hookName Hook name exposed to be used by filters.\n *\n * @return Higher-order component factory.\n *\n * ```jsx\n * import { withFilters } from '@wordpress/components';\n * import { addFilter } from '@wordpress/hooks';\n *\n * const MyComponent = ( { title } ) => <h1>{ title }</h1>;\n *\n * const ComponentToAppend = () => <div>Appended component</div>;\n *\n * function withComponentAppended( FilteredComponent ) {\n * \treturn ( props ) => (\n * \t\t<>\n * \t\t\t<FilteredComponent { ...props } />\n * \t\t\t<ComponentToAppend />\n * \t\t</>\n * \t);\n * }\n *\n * addFilter(\n * \t'MyHookName',\n * \t'my-plugin/with-component-appended',\n * \twithComponentAppended\n * );\n *\n * const MyComponentWithFilters = withFilters( 'MyHookName' )( MyComponent );\n * ```\n */\nexport default function withFilters(hookName) {\n  return createHigherOrderComponent(OriginalComponent => {\n    const namespace = 'core/with-filters/' + hookName;\n\n    /**\n     * The component definition with current filters applied. Each instance\n     * reuse this shared reference as an optimization to avoid excessive\n     * calls to `applyFilters` when many instances exist.\n     */\n    let FilteredComponent;\n\n    /**\n     * Initializes the FilteredComponent variable once, if not already\n     * assigned. Subsequent calls are effectively a noop.\n     */\n    function ensureFilteredComponent() {\n      if (FilteredComponent === undefined) {\n        FilteredComponent = applyFilters(hookName, OriginalComponent);\n      }\n    }\n    class FilteredComponentRenderer extends Component {\n      constructor(props) {\n        super(props);\n        ensureFilteredComponent();\n      }\n      componentDidMount() {\n        FilteredComponentRenderer.instances.push(this);\n\n        // If there were previously no mounted instances for components\n        // filtered on this hook, add the hook handler.\n        if (FilteredComponentRenderer.instances.length === 1) {\n          addAction('hookRemoved', namespace, onHooksUpdated);\n          addAction('hookAdded', namespace, onHooksUpdated);\n        }\n      }\n      componentWillUnmount() {\n        FilteredComponentRenderer.instances = FilteredComponentRenderer.instances.filter(instance => instance !== this);\n\n        // If this was the last of the mounted components filtered on\n        // this hook, remove the hook handler.\n        if (FilteredComponentRenderer.instances.length === 0) {\n          removeAction('hookRemoved', namespace);\n          removeAction('hookAdded', namespace);\n        }\n      }\n      render() {\n        return /*#__PURE__*/_jsx(FilteredComponent, {\n          ...this.props\n        });\n      }\n    }\n    FilteredComponentRenderer.instances = [];\n\n    /**\n     * Updates the FilteredComponent definition, forcing a render for each\n     * mounted instance. This occurs a maximum of once per animation frame.\n     */\n    const throttledForceUpdate = debounce(() => {\n      // Recreate the filtered component, only after delay so that it's\n      // computed once, even if many filters added.\n      FilteredComponent = applyFilters(hookName, OriginalComponent);\n\n      // Force each instance to render.\n      FilteredComponentRenderer.instances.forEach(instance => {\n        instance.forceUpdate();\n      });\n    }, ANIMATION_FRAME_PERIOD);\n\n    /**\n     * When a filter is added or removed for the matching hook name, each\n     * mounted instance should re-render with the new filters having been\n     * applied to the original component.\n     *\n     * @param updatedHookName Name of the hook that was updated.\n     */\n    function onHooksUpdated(updatedHookName) {\n      if (updatedHookName === hookName) {\n        throttledForceUpdate();\n      }\n    }\n    return FilteredComponentRenderer;\n  }, 'withFilters');\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,qBAA0B;AAC1B,mBAAsD;AACtD,qBAAqD;AACrD,yBAA4B;AAC5B,IAAM,yBAAyB;AAsChB,SAAR,YAA6B,UAAU;AAC5C,aAAO,2CAA2B,uBAAqB;AACrD,UAAM,YAAY,uBAAuB;AAOzC,QAAI;AAMJ,aAAS,0BAA0B;AACjC,UAAI,sBAAsB,QAAW;AACnC,gCAAoB,2BAAa,UAAU,iBAAiB;AAAA,MAC9D;AAAA,IACF;AAAA,IACA,MAAM,kCAAkC,yBAAU;AAAA,MAChD,YAAY,OAAO;AACjB,cAAM,KAAK;AACX,gCAAwB;AAAA,MAC1B;AAAA,MACA,oBAAoB;AAClB,kCAA0B,UAAU,KAAK,IAAI;AAI7C,YAAI,0BAA0B,UAAU,WAAW,GAAG;AACpD,sCAAU,eAAe,WAAW,cAAc;AAClD,sCAAU,aAAa,WAAW,cAAc;AAAA,QAClD;AAAA,MACF;AAAA,MACA,uBAAuB;AACrB,kCAA0B,YAAY,0BAA0B,UAAU,OAAO,cAAY,aAAa,IAAI;AAI9G,YAAI,0BAA0B,UAAU,WAAW,GAAG;AACpD,yCAAa,eAAe,SAAS;AACrC,yCAAa,aAAa,SAAS;AAAA,QACrC;AAAA,MACF;AAAA,MACA,SAAS;AACP,eAAoB,uCAAAA,KAAK,mBAAmB;AAAA,UAC1C,GAAG,KAAK;AAAA,QACV,CAAC;AAAA,MACH;AAAA,IACF;AACA,8BAA0B,YAAY,CAAC;AAMvC,UAAM,2BAAuB,yBAAS,MAAM;AAG1C,8BAAoB,2BAAa,UAAU,iBAAiB;AAG5D,gCAA0B,UAAU,QAAQ,cAAY;AACtD,iBAAS,YAAY;AAAA,MACvB,CAAC;AAAA,IACH,GAAG,sBAAsB;AASzB,aAAS,eAAe,iBAAiB;AACvC,UAAI,oBAAoB,UAAU;AAChC,6BAAqB;AAAA,MACvB;AAAA,IACF;AACA,WAAO;AAAA,EACT,GAAG,aAAa;AAClB;",
  "names": ["_jsx"]
}
