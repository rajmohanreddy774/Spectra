{
  "version": 3,
  "sources": ["../../src/styles/utils.ts"],
  "sourcesContent": ["/**\n * External dependencies\n */\nimport { paramCase as kebabCase } from 'change-case';\n\n/**\n * Internal dependencies\n */\nimport type {\n\tCssRulesKeys,\n\tGeneratedCSSRule,\n\tStyle,\n\tBox,\n\tStyleOptions,\n} from '../types';\nimport {\n\tVARIABLE_REFERENCE_PREFIX,\n\tVARIABLE_PATH_SEPARATOR_TOKEN_ATTRIBUTE,\n\tVARIABLE_PATH_SEPARATOR_TOKEN_STYLE,\n} from './constants';\n\n/**\n * Helper util to return a value from a certain path of the object.\n * Path is specified as an array of properties, like `[ 'x', 'y' ]`.\n *\n * @param object Input object.\n * @param path   Path to the object property.\n * @return Value of the object property at the specified path.\n */\nexport const getStyleValueByPath = (\n\tobject: Record< any, any >,\n\tpath: string[]\n) => {\n\tlet value: any = object;\n\tpath.forEach( ( fieldName: string ) => {\n\t\tvalue = value?.[ fieldName ];\n\t} );\n\treturn value;\n};\n\n/**\n * Returns a JSON representation of the generated CSS rules.\n *\n * @param style   Style object.\n * @param options Options object with settings to adjust how the styles are generated.\n * @param path    An array of strings representing the path to the style value in the style object.\n * @param ruleKey A CSS property key.\n *\n * @return GeneratedCSSRule[] CSS rules.\n */\nexport function generateRule(\n\tstyle: Style,\n\toptions: StyleOptions,\n\tpath: string[],\n\truleKey: string\n): GeneratedCSSRule[] {\n\tconst styleValue: string | undefined = getStyleValueByPath( style, path );\n\n\treturn styleValue\n\t\t? [\n\t\t\t\t{\n\t\t\t\t\tselector: options?.selector,\n\t\t\t\t\tkey: ruleKey,\n\t\t\t\t\tvalue: getCSSValueFromRawStyle( styleValue ),\n\t\t\t\t},\n\t\t  ]\n\t\t: [];\n}\n\n/**\n * Returns a JSON representation of the generated CSS rules taking into account box model properties, top, right, bottom, left.\n *\n * @param style                Style object.\n * @param options              Options object with settings to adjust how the styles are generated.\n * @param path                 An array of strings representing the path to the style value in the style object.\n * @param ruleKeys             An array of CSS property keys and patterns.\n * @param individualProperties The \"sides\" or individual properties for which to generate rules.\n *\n * @return GeneratedCSSRule[]  CSS rules.\n */\nexport function generateBoxRules(\n\tstyle: Style,\n\toptions: StyleOptions,\n\tpath: string[],\n\truleKeys: CssRulesKeys,\n\tindividualProperties: string[] = [ 'top', 'right', 'bottom', 'left' ]\n): GeneratedCSSRule[] {\n\tconst boxStyle: Box | string | undefined = getStyleValueByPath(\n\t\tstyle,\n\t\tpath\n\t);\n\tif ( ! boxStyle ) {\n\t\treturn [];\n\t}\n\n\tconst rules: GeneratedCSSRule[] = [];\n\tif ( typeof boxStyle === 'string' ) {\n\t\trules.push( {\n\t\t\tselector: options?.selector,\n\t\t\tkey: ruleKeys.default,\n\t\t\tvalue: getCSSValueFromRawStyle( boxStyle ),\n\t\t} );\n\t} else {\n\t\tconst sideRules = individualProperties.reduce(\n\t\t\t( acc: GeneratedCSSRule[], side: string ) => {\n\t\t\t\tconst value = getCSSValueFromRawStyle(\n\t\t\t\t\tgetStyleValueByPath( boxStyle, [ side ] )\n\t\t\t\t);\n\t\t\t\tif ( value ) {\n\t\t\t\t\tacc.push( {\n\t\t\t\t\t\tselector: options?.selector,\n\t\t\t\t\t\tkey: ruleKeys?.individual.replace(\n\t\t\t\t\t\t\t'%s',\n\t\t\t\t\t\t\tupperFirst( side )\n\t\t\t\t\t\t),\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\treturn acc;\n\t\t\t},\n\t\t\t[]\n\t\t);\n\t\trules.push( ...sideRules );\n\t}\n\n\treturn rules;\n}\n\n/**\n * Returns a WordPress CSS custom var value from incoming style preset value,\n * if one is detected.\n *\n * The preset value is a string and follows the pattern `var:description|context|slug`.\n *\n * Example:\n *\n * `getCSSValueFromRawStyle( 'var:preset|color|heavenlyBlue' )` // returns 'var(--wp--preset--color--heavenly-blue)'\n *\n * @param styleValue A string representing a raw CSS value. Non-strings won't be processed.\n *\n * @return A CSS custom var value if the incoming style value is a preset value.\n */\n\nexport function getCSSValueFromRawStyle< StyleValue = string >(\n\tstyleValue: StyleValue\n): StyleValue {\n\tif (\n\t\ttypeof styleValue === 'string' &&\n\t\tstyleValue.startsWith( VARIABLE_REFERENCE_PREFIX )\n\t) {\n\t\tconst variable = styleValue\n\t\t\t.slice( VARIABLE_REFERENCE_PREFIX.length )\n\t\t\t.split( VARIABLE_PATH_SEPARATOR_TOKEN_ATTRIBUTE )\n\t\t\t.map( ( presetVariable ) =>\n\t\t\t\tkebabCase( presetVariable, {\n\t\t\t\t\tsplitRegexp: [\n\t\t\t\t\t\t/([a-z0-9])([A-Z])/g, // fooBar => foo-bar, 3Bar => 3-bar\n\t\t\t\t\t\t/([0-9])([a-z])/g, // 3bar => 3-bar\n\t\t\t\t\t\t/([A-Za-z])([0-9])/g, // Foo3 => foo-3, foo3 => foo-3\n\t\t\t\t\t\t/([A-Z])([A-Z][a-z])/g, // FOOBar => foo-bar\n\t\t\t\t\t],\n\t\t\t\t} )\n\t\t\t)\n\t\t\t.join( VARIABLE_PATH_SEPARATOR_TOKEN_STYLE );\n\t\treturn `var(--wp--${ variable })` as StyleValue;\n\t}\n\treturn styleValue;\n}\n\n/**\n * Capitalizes the first letter in a string.\n *\n * @param string The string whose first letter the function will capitalize.\n *\n * @return String with the first letter capitalized.\n */\nexport function upperFirst( string: string ): string {\n\tconst [ firstLetter, ...rest ] = string;\n\treturn firstLetter.toUpperCase() + rest.join( '' );\n}\n\n/**\n * Converts an array of strings into a camelCase string.\n *\n * @param strings The strings to join into a camelCase string.\n *\n * @return camelCase string.\n */\nexport function camelCaseJoin( strings: string[] ): string {\n\tconst [ firstItem, ...rest ] = strings;\n\treturn firstItem.toLowerCase() + rest.map( upperFirst ).join( '' );\n}\n\n/**\n * Safely decodes a URI with `decodeURI`. Returns the URI unmodified if\n * `decodeURI` throws an error.\n *\n * @param {string} uri URI to decode.\n *\n * @example\n * ```js\n * const badUri = safeDecodeURI( '%z' ); // does not throw an Error, simply returns '%z'\n * ```\n *\n * @return {string} Decoded URI if possible.\n */\nexport function safeDecodeURI( uri: string ): string {\n\ttry {\n\t\treturn decodeURI( uri );\n\t} catch ( uriError ) {\n\t\treturn uri;\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,yBAAuC;AAYvC,uBAIO;AAUA,IAAM,sBAAsB,CAClC,QACA,SACI;AACJ,MAAI,QAAa;AACjB,OAAK,QAAS,CAAE,cAAuB;AACtC,YAAQ,QAAS,SAAU;AAAA,EAC5B,CAAE;AACF,SAAO;AACR;AAYO,SAAS,aACf,OACA,SACA,MACA,SACqB;AACrB,QAAM,aAAiC,oBAAqB,OAAO,IAAK;AAExE,SAAO,aACJ;AAAA,IACA;AAAA,MACC,UAAU,SAAS;AAAA,MACnB,KAAK;AAAA,MACL,OAAO,wBAAyB,UAAW;AAAA,IAC5C;AAAA,EACA,IACA,CAAC;AACL;AAaO,SAAS,iBACf,OACA,SACA,MACA,UACA,uBAAiC,CAAE,OAAO,SAAS,UAAU,MAAO,GAC/C;AACrB,QAAM,WAAqC;AAAA,IAC1C;AAAA,IACA;AAAA,EACD;AACA,MAAK,CAAE,UAAW;AACjB,WAAO,CAAC;AAAA,EACT;AAEA,QAAM,QAA4B,CAAC;AACnC,MAAK,OAAO,aAAa,UAAW;AACnC,UAAM,KAAM;AAAA,MACX,UAAU,SAAS;AAAA,MACnB,KAAK,SAAS;AAAA,MACd,OAAO,wBAAyB,QAAS;AAAA,IAC1C,CAAE;AAAA,EACH,OAAO;AACN,UAAM,YAAY,qBAAqB;AAAA,MACtC,CAAE,KAAyB,SAAkB;AAC5C,cAAM,QAAQ;AAAA,UACb,oBAAqB,UAAU,CAAE,IAAK,CAAE;AAAA,QACzC;AACA,YAAK,OAAQ;AACZ,cAAI,KAAM;AAAA,YACT,UAAU,SAAS;AAAA,YACnB,KAAK,UAAU,WAAW;AAAA,cACzB;AAAA,cACA,WAAY,IAAK;AAAA,YAClB;AAAA,YACA;AAAA,UACD,CAAE;AAAA,QACH;AACA,eAAO;AAAA,MACR;AAAA,MACA,CAAC;AAAA,IACF;AACA,UAAM,KAAM,GAAG,SAAU;AAAA,EAC1B;AAEA,SAAO;AACR;AAiBO,SAAS,wBACf,YACa;AACb,MACC,OAAO,eAAe,YACtB,WAAW,WAAY,0CAA0B,GAChD;AACD,UAAM,WAAW,WACf,MAAO,2CAA0B,MAAO,EACxC,MAAO,wDAAwC,EAC/C;AAAA,MAAK,CAAE,uBACP,mBAAAA,WAAW,gBAAgB;AAAA,QAC1B,aAAa;AAAA,UACZ;AAAA;AAAA,UACA;AAAA;AAAA,UACA;AAAA;AAAA,UACA;AAAA;AAAA,QACD;AAAA,MACD,CAAE;AAAA,IACH,EACC,KAAM,oDAAoC;AAC5C,WAAO,aAAc,QAAS;AAAA,EAC/B;AACA,SAAO;AACR;AASO,SAAS,WAAY,QAAyB;AACpD,QAAM,CAAE,aAAa,GAAG,IAAK,IAAI;AACjC,SAAO,YAAY,YAAY,IAAI,KAAK,KAAM,EAAG;AAClD;AASO,SAAS,cAAe,SAA4B;AAC1D,QAAM,CAAE,WAAW,GAAG,IAAK,IAAI;AAC/B,SAAO,UAAU,YAAY,IAAI,KAAK,IAAK,UAAW,EAAE,KAAM,EAAG;AAClE;AAeO,SAAS,cAAe,KAAsB;AACpD,MAAI;AACH,WAAO,UAAW,GAAI;AAAA,EACvB,SAAU,UAAW;AACpB,WAAO;AAAA,EACR;AACD;",
  "names": ["kebabCase"]
}
