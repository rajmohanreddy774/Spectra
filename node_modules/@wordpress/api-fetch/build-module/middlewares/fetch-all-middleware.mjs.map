{
  "version": 3,
  "sources": ["../../src/middlewares/fetch-all-middleware.ts"],
  "sourcesContent": ["/**\n * WordPress dependencies\n */\nimport { addQueryArgs } from '@wordpress/url';\n\n/**\n * Internal dependencies\n */\nimport apiFetch from '..';\nimport type { APIFetchMiddleware, APIFetchOptions } from '../types';\n\n/**\n * Apply query arguments to both URL and Path, whichever is present.\n *\n * @param {APIFetchOptions}                   props     The request options\n * @param {Record< string, string | number >} queryArgs\n * @return  The request with the modified query args\n */\nconst modifyQuery = (\n\t{ path, url, ...options }: APIFetchOptions,\n\tqueryArgs: Record< string, string | number >\n): APIFetchOptions => ( {\n\t...options,\n\turl: url && addQueryArgs( url, queryArgs ),\n\tpath: path && addQueryArgs( path, queryArgs ),\n} );\n\n/**\n * Duplicates parsing functionality from apiFetch.\n *\n * @param response\n * @return Parsed response json.\n */\nconst parseResponse = ( response: Response ) =>\n\tresponse.json ? response.json() : Promise.reject( response );\n\n/**\n * @param linkHeader\n * @return The parsed link header.\n */\nconst parseLinkHeader = ( linkHeader: string | null ) => {\n\tif ( ! linkHeader ) {\n\t\treturn {};\n\t}\n\tconst match = linkHeader.match( /<([^>]+)>; rel=\"next\"/ );\n\treturn match\n\t\t? {\n\t\t\t\tnext: match[ 1 ],\n\t\t  }\n\t\t: {};\n};\n\n/**\n * @param response\n * @return  The next page URL.\n */\nconst getNextPageUrl = ( response: Response ) => {\n\tconst { next } = parseLinkHeader( response.headers.get( 'link' ) );\n\treturn next;\n};\n\n/**\n * @param options\n * @return True if the request contains an unbounded query.\n */\nconst requestContainsUnboundedQuery = ( options: APIFetchOptions ) => {\n\tconst pathIsUnbounded =\n\t\t!! options.path && options.path.indexOf( 'per_page=-1' ) !== -1;\n\tconst urlIsUnbounded =\n\t\t!! options.url && options.url.indexOf( 'per_page=-1' ) !== -1;\n\treturn pathIsUnbounded || urlIsUnbounded;\n};\n\n/**\n * The REST API enforces an upper limit on the per_page option. To handle large\n * collections, apiFetch consumers can pass `per_page=-1`; this middleware will\n * then recursively assemble a full response array from all available pages.\n * @param options\n * @param next\n */\nconst fetchAllMiddleware: APIFetchMiddleware = async ( options, next ) => {\n\tif ( options.parse === false ) {\n\t\t// If a consumer has opted out of parsing, do not apply middleware.\n\t\treturn next( options );\n\t}\n\tif ( ! requestContainsUnboundedQuery( options ) ) {\n\t\t// If neither url nor path is requesting all items, do not apply middleware.\n\t\treturn next( options );\n\t}\n\n\t// Retrieve requested page of results.\n\tconst response = await apiFetch( {\n\t\t...modifyQuery( options, {\n\t\t\tper_page: 100,\n\t\t} ),\n\t\t// Ensure headers are returned for page 1.\n\t\tparse: false,\n\t} );\n\n\tconst results = await parseResponse( response );\n\n\tif ( ! Array.isArray( results ) ) {\n\t\t// We have no reliable way of merging non-array results.\n\t\treturn results;\n\t}\n\n\tlet nextPage = getNextPageUrl( response );\n\n\tif ( ! nextPage ) {\n\t\t// There are no further pages to request.\n\t\treturn results;\n\t}\n\n\t// Iteratively fetch all remaining pages until no \"next\" header is found.\n\tlet mergedResults = ( [] as Array< any > ).concat( results );\n\twhile ( nextPage ) {\n\t\tconst nextResponse = await apiFetch( {\n\t\t\t...options,\n\t\t\t// Ensure the URL for the next page is used instead of any provided path.\n\t\t\tpath: undefined,\n\t\t\turl: nextPage,\n\t\t\t// Ensure we still get headers so we can identify the next page.\n\t\t\tparse: false,\n\t\t} );\n\t\tconst nextResults = await parseResponse( nextResponse );\n\t\tmergedResults = mergedResults.concat( nextResults );\n\t\tnextPage = getNextPageUrl( nextResponse );\n\t}\n\treturn mergedResults;\n};\n\nexport default fetchAllMiddleware;\n"],
  "mappings": ";AAGA,SAAS,oBAAoB;AAK7B,OAAO,cAAc;AAUrB,IAAM,cAAc,CACnB,EAAE,MAAM,KAAK,GAAG,QAAQ,GACxB,eACuB;AAAA,EACvB,GAAG;AAAA,EACH,KAAK,OAAO,aAAc,KAAK,SAAU;AAAA,EACzC,MAAM,QAAQ,aAAc,MAAM,SAAU;AAC7C;AAQA,IAAM,gBAAgB,CAAE,aACvB,SAAS,OAAO,SAAS,KAAK,IAAI,QAAQ,OAAQ,QAAS;AAM5D,IAAM,kBAAkB,CAAE,eAA+B;AACxD,MAAK,CAAE,YAAa;AACnB,WAAO,CAAC;AAAA,EACT;AACA,QAAM,QAAQ,WAAW,MAAO,uBAAwB;AACxD,SAAO,QACJ;AAAA,IACA,MAAM,MAAO,CAAE;AAAA,EACf,IACA,CAAC;AACL;AAMA,IAAM,iBAAiB,CAAE,aAAwB;AAChD,QAAM,EAAE,KAAK,IAAI,gBAAiB,SAAS,QAAQ,IAAK,MAAO,CAAE;AACjE,SAAO;AACR;AAMA,IAAM,gCAAgC,CAAE,YAA8B;AACrE,QAAM,kBACL,CAAC,CAAE,QAAQ,QAAQ,QAAQ,KAAK,QAAS,aAAc,MAAM;AAC9D,QAAM,iBACL,CAAC,CAAE,QAAQ,OAAO,QAAQ,IAAI,QAAS,aAAc,MAAM;AAC5D,SAAO,mBAAmB;AAC3B;AASA,IAAM,qBAAyC,OAAQ,SAAS,SAAU;AACzE,MAAK,QAAQ,UAAU,OAAQ;AAE9B,WAAO,KAAM,OAAQ;AAAA,EACtB;AACA,MAAK,CAAE,8BAA+B,OAAQ,GAAI;AAEjD,WAAO,KAAM,OAAQ;AAAA,EACtB;AAGA,QAAM,WAAW,MAAM,SAAU;AAAA,IAChC,GAAG,YAAa,SAAS;AAAA,MACxB,UAAU;AAAA,IACX,CAAE;AAAA;AAAA,IAEF,OAAO;AAAA,EACR,CAAE;AAEF,QAAM,UAAU,MAAM,cAAe,QAAS;AAE9C,MAAK,CAAE,MAAM,QAAS,OAAQ,GAAI;AAEjC,WAAO;AAAA,EACR;AAEA,MAAI,WAAW,eAAgB,QAAS;AAExC,MAAK,CAAE,UAAW;AAEjB,WAAO;AAAA,EACR;AAGA,MAAI,gBAAkB,CAAC,EAAoB,OAAQ,OAAQ;AAC3D,SAAQ,UAAW;AAClB,UAAM,eAAe,MAAM,SAAU;AAAA,MACpC,GAAG;AAAA;AAAA,MAEH,MAAM;AAAA,MACN,KAAK;AAAA;AAAA,MAEL,OAAO;AAAA,IACR,CAAE;AACF,UAAM,cAAc,MAAM,cAAe,YAAa;AACtD,oBAAgB,cAAc,OAAQ,WAAY;AAClD,eAAW,eAAgB,YAAa;AAAA,EACzC;AACA,SAAO;AACR;AAEA,IAAO,+BAAQ;",
  "names": []
}
