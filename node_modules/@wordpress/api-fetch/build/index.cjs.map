{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["/**\n * WordPress dependencies\n */\nimport { __ } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\nimport createNonceMiddleware from './middlewares/nonce';\nimport createRootURLMiddleware from './middlewares/root-url';\nimport createPreloadingMiddleware from './middlewares/preloading';\nimport fetchAllMiddleware from './middlewares/fetch-all-middleware';\nimport namespaceEndpointMiddleware from './middlewares/namespace-endpoint';\nimport httpV1Middleware from './middlewares/http-v1';\nimport userLocaleMiddleware from './middlewares/user-locale';\nimport mediaUploadMiddleware from './middlewares/media-upload';\nimport createThemePreviewMiddleware from './middlewares/theme-preview';\nimport {\n\tparseResponseAndNormalizeError,\n\tparseAndThrowError,\n} from './utils/response';\nimport type {\n\tAPIFetchMiddleware,\n\tAPIFetchOptions,\n\tFetchHandler,\n} from './types';\n\n/**\n * Default set of header values which should be sent with every request unless\n * explicitly provided through apiFetch options.\n */\nconst DEFAULT_HEADERS: APIFetchOptions[ 'headers' ] = {\n\t// The backend uses the Accept header as a condition for considering an\n\t// incoming request as a REST request.\n\t//\n\t// See: https://core.trac.wordpress.org/ticket/44534\n\tAccept: 'application/json, */*;q=0.1',\n};\n\n/**\n * Default set of fetch option values which should be sent with every request\n * unless explicitly provided through apiFetch options.\n */\nconst DEFAULT_OPTIONS: APIFetchOptions = {\n\tcredentials: 'include',\n};\n\nconst middlewares: Array< APIFetchMiddleware > = [\n\tuserLocaleMiddleware,\n\tnamespaceEndpointMiddleware,\n\thttpV1Middleware,\n\tfetchAllMiddleware,\n];\n\n/**\n * Register a middleware\n *\n * @param middleware\n */\nfunction registerMiddleware( middleware: APIFetchMiddleware ) {\n\tmiddlewares.unshift( middleware );\n}\n\nconst defaultFetchHandler: FetchHandler = ( nextOptions ) => {\n\tconst { url, path, data, parse = true, ...remainingOptions } = nextOptions;\n\tlet { body, headers } = nextOptions;\n\n\t// Merge explicitly-provided headers with default values.\n\theaders = { ...DEFAULT_HEADERS, ...headers };\n\n\t// The `data` property is a shorthand for sending a JSON body.\n\tif ( data ) {\n\t\tbody = JSON.stringify( data );\n\t\theaders[ 'Content-Type' ] = 'application/json';\n\t}\n\n\tconst responsePromise = globalThis.fetch(\n\t\t// Fall back to explicitly passing `window.location` which is the behavior if `undefined` is passed.\n\t\turl || path || window.location.href,\n\t\t{\n\t\t\t...DEFAULT_OPTIONS,\n\t\t\t...remainingOptions,\n\t\t\tbody,\n\t\t\theaders,\n\t\t}\n\t);\n\n\treturn responsePromise.then(\n\t\t( response ) => {\n\t\t\t// If the response is not 2xx, still parse the response body as JSON\n\t\t\t// but throw the JSON as error.\n\t\t\tif ( ! response.ok ) {\n\t\t\t\treturn parseAndThrowError( response, parse );\n\t\t\t}\n\n\t\t\treturn parseResponseAndNormalizeError( response, parse );\n\t\t},\n\t\t( err ) => {\n\t\t\t// Re-throw AbortError for the users to handle it themselves.\n\t\t\tif ( err && err.name === 'AbortError' ) {\n\t\t\t\tthrow err;\n\t\t\t}\n\n\t\t\t// If the browser reports being offline, we'll just assume that\n\t\t\t// this is why the request failed.\n\t\t\tif ( ! globalThis.navigator.onLine ) {\n\t\t\t\tthrow {\n\t\t\t\t\tcode: 'offline_error',\n\t\t\t\t\tmessage: __(\n\t\t\t\t\t\t'Unable to connect. Please check your Internet connection.'\n\t\t\t\t\t),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Hard to diagnose further due to how Window.fetch reports errors.\n\t\t\tthrow {\n\t\t\t\tcode: 'fetch_error',\n\t\t\t\tmessage: __(\n\t\t\t\t\t'Could not get a valid response from the server.'\n\t\t\t\t),\n\t\t\t};\n\t\t}\n\t);\n};\n\nlet fetchHandler = defaultFetchHandler;\n\n/**\n * Defines a custom fetch handler for making the requests that will override\n * the default one using window.fetch\n *\n * @param newFetchHandler The new fetch handler\n */\nfunction setFetchHandler( newFetchHandler: FetchHandler ) {\n\tfetchHandler = newFetchHandler;\n}\n\nexport interface ApiFetch {\n\t< T, Parse extends boolean = true >(\n\t\toptions: APIFetchOptions< Parse >\n\t): Promise< Parse extends true ? T : Response >;\n\tnonceEndpoint?: string;\n\tnonceMiddleware?: ReturnType< typeof createNonceMiddleware >;\n\tuse: ( middleware: APIFetchMiddleware ) => void;\n\tsetFetchHandler: ( newFetchHandler: FetchHandler ) => void;\n\tcreateNonceMiddleware: typeof createNonceMiddleware;\n\tcreatePreloadingMiddleware: typeof createPreloadingMiddleware;\n\tcreateRootURLMiddleware: typeof createRootURLMiddleware;\n\tfetchAllMiddleware: typeof fetchAllMiddleware;\n\tmediaUploadMiddleware: typeof mediaUploadMiddleware;\n\tcreateThemePreviewMiddleware: typeof createThemePreviewMiddleware;\n}\n\n/**\n * Fetch\n *\n * @param options The options for the fetch.\n * @return A promise representing the request processed via the registered middlewares.\n */\nexport const apiFetch: ApiFetch = ( options ) => {\n\t// creates a nested function chain that calls all middlewares and finally the `fetchHandler`,\n\t// converting `middlewares = [ m1, m2, m3 ]` into:\n\t// ```\n\t// opts1 => m1( opts1, opts2 => m2( opts2, opts3 => m3( opts3, fetchHandler ) ) );\n\t// ```\n\tconst enhancedHandler = middlewares.reduceRight< FetchHandler >(\n\t\t( next, middleware ) => {\n\t\t\treturn ( workingOptions ) => middleware( workingOptions, next );\n\t\t},\n\t\tfetchHandler\n\t);\n\n\treturn enhancedHandler( options ).catch( ( error ) => {\n\t\tif ( error.code !== 'rest_cookie_invalid_nonce' ) {\n\t\t\treturn Promise.reject( error );\n\t\t}\n\n\t\t// If the nonce is invalid, refresh it and try again.\n\t\treturn globalThis\n\t\t\t.fetch( apiFetch.nonceEndpoint! )\n\t\t\t.then( ( response ) => {\n\t\t\t\t// If the nonce refresh fails, it means we failed to recover from the original\n\t\t\t\t// `rest_cookie_invalid_nonce` error and that it's time to finally re-throw it.\n\t\t\t\tif ( ! response.ok ) {\n\t\t\t\t\treturn Promise.reject( error );\n\t\t\t\t}\n\n\t\t\t\treturn response.text();\n\t\t\t} )\n\t\t\t.then( ( text ) => {\n\t\t\t\tapiFetch.nonceMiddleware!.nonce = text;\n\t\t\t\treturn apiFetch( options );\n\t\t\t} );\n\t} );\n};\n\napiFetch.use = registerMiddleware;\napiFetch.setFetchHandler = setFetchHandler;\n\napiFetch.createNonceMiddleware = createNonceMiddleware;\napiFetch.createPreloadingMiddleware = createPreloadingMiddleware;\napiFetch.createRootURLMiddleware = createRootURLMiddleware;\napiFetch.fetchAllMiddleware = fetchAllMiddleware;\napiFetch.mediaUploadMiddleware = mediaUploadMiddleware;\napiFetch.createThemePreviewMiddleware = createThemePreviewMiddleware;\n\nexport default apiFetch;\nexport type * from './types';\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,kBAAmB;AAKnB,mBAAkC;AAClC,sBAAoC;AACpC,wBAAuC;AACvC,kCAA+B;AAC/B,gCAAwC;AACxC,qBAA6B;AAC7B,yBAAiC;AACjC,0BAAkC;AAClC,2BAAyC;AACzC,sBAGO;AAWP,IAAM,kBAAgD;AAAA;AAAA;AAAA;AAAA;AAAA,EAKrD,QAAQ;AACT;AAMA,IAAM,kBAAmC;AAAA,EACxC,aAAa;AACd;AAEA,IAAM,cAA2C;AAAA,EAChD,mBAAAA;AAAA,EACA,0BAAAC;AAAA,EACA,eAAAC;AAAA,EACA,4BAAAC;AACD;AAOA,SAAS,mBAAoB,YAAiC;AAC7D,cAAY,QAAS,UAAW;AACjC;AAEA,IAAM,sBAAoC,CAAE,gBAAiB;AAC5D,QAAM,EAAE,KAAK,MAAM,MAAM,QAAQ,MAAM,GAAG,iBAAiB,IAAI;AAC/D,MAAI,EAAE,MAAM,QAAQ,IAAI;AAGxB,YAAU,EAAE,GAAG,iBAAiB,GAAG,QAAQ;AAG3C,MAAK,MAAO;AACX,WAAO,KAAK,UAAW,IAAK;AAC5B,YAAS,cAAe,IAAI;AAAA,EAC7B;AAEA,QAAM,kBAAkB,WAAW;AAAA;AAAA,IAElC,OAAO,QAAQ,OAAO,SAAS;AAAA,IAC/B;AAAA,MACC,GAAG;AAAA,MACH,GAAG;AAAA,MACH;AAAA,MACA;AAAA,IACD;AAAA,EACD;AAEA,SAAO,gBAAgB;AAAA,IACtB,CAAE,aAAc;AAGf,UAAK,CAAE,SAAS,IAAK;AACpB,mBAAO,oCAAoB,UAAU,KAAM;AAAA,MAC5C;AAEA,iBAAO,gDAAgC,UAAU,KAAM;AAAA,IACxD;AAAA,IACA,CAAE,QAAS;AAEV,UAAK,OAAO,IAAI,SAAS,cAAe;AACvC,cAAM;AAAA,MACP;AAIA,UAAK,CAAE,WAAW,UAAU,QAAS;AACpC,cAAM;AAAA,UACL,MAAM;AAAA,UACN,aAAS;AAAA,YACR;AAAA,UACD;AAAA,QACD;AAAA,MACD;AAGA,YAAM;AAAA,QACL,MAAM;AAAA,QACN,aAAS;AAAA,UACR;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACD;AAEA,IAAI,eAAe;AAQnB,SAAS,gBAAiB,iBAAgC;AACzD,iBAAe;AAChB;AAwBO,IAAM,WAAqB,CAAE,YAAa;AAMhD,QAAM,kBAAkB,YAAY;AAAA,IACnC,CAAE,MAAM,eAAgB;AACvB,aAAO,CAAE,mBAAoB,WAAY,gBAAgB,IAAK;AAAA,IAC/D;AAAA,IACA;AAAA,EACD;AAEA,SAAO,gBAAiB,OAAQ,EAAE,MAAO,CAAE,UAAW;AACrD,QAAK,MAAM,SAAS,6BAA8B;AACjD,aAAO,QAAQ,OAAQ,KAAM;AAAA,IAC9B;AAGA,WAAO,WACL,MAAO,SAAS,aAAe,EAC/B,KAAM,CAAE,aAAc;AAGtB,UAAK,CAAE,SAAS,IAAK;AACpB,eAAO,QAAQ,OAAQ,KAAM;AAAA,MAC9B;AAEA,aAAO,SAAS,KAAK;AAAA,IACtB,CAAE,EACD,KAAM,CAAE,SAAU;AAClB,eAAS,gBAAiB,QAAQ;AAClC,aAAO,SAAU,OAAQ;AAAA,IAC1B,CAAE;AAAA,EACJ,CAAE;AACH;AAEA,SAAS,MAAM;AACf,SAAS,kBAAkB;AAE3B,SAAS,wBAAwB,aAAAC;AACjC,SAAS,6BAA6B,kBAAAC;AACtC,SAAS,0BAA0B,gBAAAC;AACnC,SAAS,qBAAqB,4BAAAH;AAC9B,SAAS,wBAAwB,oBAAAI;AACjC,SAAS,+BAA+B,qBAAAC;AAExC,IAAO,gBAAQ;",
  "names": ["userLocaleMiddleware", "namespaceEndpointMiddleware", "httpV1Middleware", "fetchAllMiddleware", "createNonceMiddleware", "createPreloadingMiddleware", "createRootURLMiddleware", "mediaUploadMiddleware", "createThemePreviewMiddleware"]
}
